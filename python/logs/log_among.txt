Analysis object initialized
{'among': 6, 'amovnge': 1, 'i': 1, 'imong': 1, 'm': 3, 'mang': 55, 'manáµ¹': 1, 'mange': 3, 'manges': 1, 'mangis': 2, 'menges': 1, 'moages': 1, 'mon': 4, 'mong': 115, 'monge': 2, 'monges': 1, 'mongue': 1, 'mongus': 1}
Lexel initialized
[[{'lit': 'ng', 'ln': 2, 'index': 3}]]
[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
MIN pattern length=5
Pattern CVCVC is valid
Pattern CVCCV is valid
Pattern CVCCVC is valid
Pattern CVCV is invalid
Pattern CVCCC is valid
Pattern CVCC is invalid
Pattern VCVCC is valid
Pattern VCVC is invalid
Pattern CVC is invalid
Pattern C is invalid
Pattern CVCCCC is invalid
	[[{'lit': 'ng', 'ln': 2, 'index': 3}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	MIN pattern length=5
	Pattern CVCVC is valid
	Pattern CVCCV is valid
	Pattern CVCCVC is valid
	Pattern CVCV is invalid
	Pattern CVCCC is valid
	Pattern CVCC is invalid
	Pattern VCVCC is valid
	Pattern VCVC is invalid
	Pattern CVC is invalid
	Pattern C is invalid
	Pattern CVCCCC is invalid
	Making the selection for pattern: CVCVC
	Selection for pattern: CVCVC completed
	Making a version for pattern: CVCVC
			___CVCVC : 0___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: a/m/o/n/g
					TRYING: a
					> version: a/m/o/ng
					TRYING: a
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', 'm', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', 'm', 'o', 'ng']
				a/m/o/n/g(VCVCC)
a/m/o/ng(VCVC)
_/a/m/o/n/g(AVCVCC)
_/a/m/o/ng(AVCVC)
				version split: ['a', 'm', 'o', 'n', 'g']
				{'string': 'a', 'rgx': '((_))$'}
				_____REMOVING________['a', 'm', 'o', 'n', 'g']
				version split: ['a', 'm', 'o', 'ng']
				{'string': 'a', 'rgx': '((_))$'}
				_____REMOVING________['a', 'm', 'o', 'ng']
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_', 'rgx': '((_))$'}
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_', 'rgx': '((_))$'}
				ANALYSING: m
					resolving (1)
					> version: m
					TRYING: m
					RESULT:  ['m']
				version split: ['m']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: m
					> version: m/a/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: m
					> version: m/a/ng/e
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'o', 'n']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: m
					> version: m/o/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: m
					> version: m/o/ng/e
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm', 'rgx': '((m))$'}
			___CVCVC : 1___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/o/n/g
					TRYING: a
					> version: _/a/m/o/ng
					TRYING: a
					RESULT:  ['a']
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_/a', 'rgx': '((_))/((a))$'}
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_/a', 'rgx': '((_))/((a))$'}
				ANALYSING: m
					resolving (1)
					> version: m
					RESULT:  ['_']
				adding dashed alternative: ['m', '_']
				m(C)
m/_(CA)
				version split: ['m']
				{'string': 'm', 'rgx': '((m))/((_))$'}
				_____REMOVING________['m']
				version split: ['m', '_']
				{'string': 'm/_', 'rgx': '((m))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: a
					> version: m/a/ng
					TRYING: a
					RESULT:  ['a']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: a
					> version: m/a/ng/e
					TRYING: a
					RESULT:  ['a']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: o
					RESULT:  ['o']
				version split: ['m', 'o', 'n']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: o
					> version: m/o/ng
					TRYING: o
					RESULT:  ['o']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: o
					> version: m/o/ng/e
					TRYING: o
					RESULT:  ['o']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
			___CVCVC : 2___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/o/n/g
					TRYING: m
					adding blocked set: C = C >> m, ng
					> version: _/a/m/o/ng
					TRYING: m
					adding blocked set: C = C >> m, ng
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', '_', 'm', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', '_', 'm', 'o', 'ng']
				_/a/m/o/n/g(AVCVCC)
_/a/m/o/ng(AVCVC)
_/a/_/m/o/n/g(AVACVCC)
_/a/_/m/o/ng(AVACVC)
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_/a/m', 'rgx': '((_))/((a))/((_))$'}
				_____REMOVING________['_', 'a', 'm', 'o', 'n', 'g']
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_/a/m', 'rgx': '((_))/((a))/((_))$'}
				_____REMOVING________['_', 'a', 'm', 'o', 'ng']
				version split: ['_', 'a', '_', 'm', 'o', 'n', 'g']
				{'string': '_/a/_', 'rgx': '((_))/((a))/((_))$'}
				version split: ['_', 'a', '_', 'm', 'o', 'ng']
				{'string': '_/a/_', 'rgx': '((_))/((a))/((_))$'}
				ANALYSING: m
					resolving (1)
					> version: m/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_']
				m/_(CA)
m/_/_(CAA)
				version split: ['m', '_']
				{'string': 'm/_', 'rgx': '((m))/((_))/((_))$'}
				_____REMOVING________['m', '_']
				version split: ['m', '_', '_']
				{'string': 'm/_/_', 'rgx': '((m))/((_))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: n
					> version: m/a/ng
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a/n', 'rgx': '((m))/((a))/((n)|(ng))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm/a/ng', 'rgx': '((m))/((a))/((n)|(ng))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: n
					> version: m/a/ng/e
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm/a/n', 'rgx': '((m))/((a))/((n)|(ng))$'}
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm/a/ng', 'rgx': '((m))/((a))/((n)|(ng))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: n
					RESULT:  ['n']
				version split: ['m', 'o', 'n']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: n
					> version: m/o/ng
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n)|(ng))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm/o/ng', 'rgx': '((m))/((o))/((n)|(ng))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: n
					> version: m/o/ng/e
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n)|(ng))$'}
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm/o/ng', 'rgx': '((m))/((o))/((n)|(ng))$'}
			___CVCVC : 3___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/_/m/o/n/g
					TRYING: m
					> version: _/a/_/m/o/ng
					TRYING: m
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', '_', '_', 'm', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', '_', '_', 'm', 'o', 'ng']
				_/a/_/m/o/n/g(AVACVCC)
_/a/_/m/o/ng(AVACVC)
_/a/_/_/m/o/n/g(AVAACVCC)
_/a/_/_/m/o/ng(AVAACVC)
				version split: ['_', 'a', '_', 'm', 'o', 'n', 'g']
				{'string': '_/a/_/m', 'rgx': '((_))/((a))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', 'm', 'o', 'n', 'g']
				version split: ['_', 'a', '_', 'm', 'o', 'ng']
				{'string': '_/a/_/m', 'rgx': '((_))/((a))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', 'm', 'o', 'ng']
				version split: ['_', 'a', '_', '_', 'm', 'o', 'n', 'g']
				{'string': '_/a/_/_', 'rgx': '((_))/((a))/((_))/((_))$'}
				version split: ['_', 'a', '_', '_', 'm', 'o', 'ng']
				{'string': '_/a/_/_', 'rgx': '((_))/((a))/((_))/((_))$'}
				ANALYSING: m
					resolving (1)
					> version: m/_/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_', '_']
				m/_/_(CAA)
m/_/_/_(CAAA)
				version split: ['m', '_', '_']
				{'string': 'm/_/_', 'rgx': '((m))/((_))/((_))/((_))$'}
				_____REMOVING________['m', '_', '_']
				version split: ['m', '_', '_', '_']
				{'string': 'm/_/_/_', 'rgx': '((m))/((_))/((_))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: g
					> version: m/a/ng
					RESULT:  ['_']
				adding dashed alternative: ['m', 'a', 'n', '_', 'g']
				adding dashed alternative: ['m', 'a', 'ng', '_']
				m/a/n/g(CVCC)
m/a/ng(CVC)
m/a/n/_/g(CVCAC)
m/a/ng/_(CVCA)
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a/n/g', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'a', 'n', 'g']
				version split: ['m', 'a', 'ng']
				{'string': 'm/a/ng', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'a', 'ng']
				version split: ['m', 'a', 'n', '_', 'g']
				{'string': 'm/a/n/_', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				version split: ['m', 'a', 'ng', '_']
				{'string': 'm/a/ng/_', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: g
					> version: m/a/ng/e
					TRYING: e
					RESULT:  ['e']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm/a/n/g', 'rgx': '((m))/((a))/((n)|(ng))/((e))$'}
				_____REMOVING________['m', 'a', 'n', 'g', 'e']
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm/a/ng/e', 'rgx': '((m))/((a))/((n)|(ng))/((e))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_']
				m/o/n(CVC)
m/o/n/_(CVCA)
				version split: ['m', 'o', 'n']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n))/((_))$'}
				_____REMOVING________['m', 'o', 'n']
				version split: ['m', 'o', 'n', '_']
				{'string': 'm/o/n/_', 'rgx': '((m))/((o))/((n))/((_))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: g
					> version: m/o/ng
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_', 'g']
				adding dashed alternative: ['m', 'o', 'ng', '_']
				m/o/n/g(CVCC)
m/o/ng(CVC)
m/o/n/_/g(CVCAC)
m/o/ng/_(CVCA)
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o/n/g', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'o', 'n', 'g']
				version split: ['m', 'o', 'ng']
				{'string': 'm/o/ng', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'o', 'ng']
				version split: ['m', 'o', 'n', '_', 'g']
				{'string': 'm/o/n/_', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
				version split: ['m', 'o', 'ng', '_']
				{'string': 'm/o/ng/_', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: g
					> version: m/o/ng/e
					TRYING: e
					RESULT:  ['e']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm/o/n/g', 'rgx': '((m))/((o))/((n)|(ng))/((e))$'}
				_____REMOVING________['m', 'o', 'n', 'g', 'e']
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm/o/ng/e', 'rgx': '((m))/((o))/((n)|(ng))/((e))$'}
			___CVCVC : 4___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/_/_/m/o/n/g
					TRYING: m
					adding blocked set: C = C >> m, s
					> version: _/a/_/_/m/o/ng
					TRYING: m
					adding blocked set: C = C >> m, s
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', '_', '_', '_', 'm', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', '_', '_', '_', 'm', 'o', 'ng']
				_/a/_/_/m/o/n/g(AVAACVCC)
_/a/_/_/m/o/ng(AVAACVC)
_/a/_/_/_/m/o/n/g(AVAAACVCC)
_/a/_/_/_/m/o/ng(AVAAACVC)
				version split: ['_', 'a', '_', '_', 'm', 'o', 'n', 'g']
				{'string': '_/a/_/_/m/o', 'rgx': '((_))/((a))/((_))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', '_', 'm', 'o', 'n', 'g']
				version split: ['_', 'a', '_', '_', 'm', 'o', 'ng']
				{'string': '_/a/_/_/m/o', 'rgx': '((_))/((a))/((_))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', '_', 'm', 'o', 'ng']
				version split: ['_', 'a', '_', '_', '_', 'm', 'o', 'n', 'g']
				{'string': '_/a/_/_/_/m', 'rgx': '((_))/((a))/((_))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', '_', '_', 'm', 'o', 'n', 'g']
				version split: ['_', 'a', '_', '_', '_', 'm', 'o', 'ng']
				{'string': '_/a/_/_/_/m', 'rgx': '((_))/((a))/((_))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', '_', '_', 'm', 'o', 'ng']
				ANALYSING: m
					resolving (1)
					> version: m/_/_/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_', '_', '_']
				m/_/_/_(CAAA)
m/_/_/_/_(CAAAA)
				version split: ['m', '_', '_', '_']
				{'string': 'm/_/_/_', 'rgx': '((m))/((_))/((_))/((_))/((_))$'}
				_____REMOVING________['m', '_', '_', '_']
				version split: ['m', '_', '_', '_', '_']
				{'string': 'm/_/_/_/_', 'rgx': '((m))/((_))/((_))/((_))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/_/g
					TRYING: g
					adding blocked set: C = C >> g, _, s
					> version: m/a/ng/_
					RESULT:  ['_']
				adding dashed alternative: ['m', 'a', 'n', '_', '_', 'g']
				adding dashed alternative: ['m', 'a', 'ng', '_', '_']
				m/a/n/_/g(CVCAC)
m/a/ng/_(CVCA)
m/a/n/_/_/g(CVCAAC)
m/a/ng/_/_(CVCAA)
				version split: ['m', 'a', 'n', '_', 'g']
				{'string': 'm/a/n/_/g', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'a', 'n', '_', 'g']
				version split: ['m', 'a', 'ng', '_']
				{'string': 'm/a/ng/_', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'a', 'ng', '_']
				version split: ['m', 'a', 'n', '_', '_', 'g']
				{'string': 'm/a/n/_/_/g', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'a', 'n', '_', '_', 'g']
				version split: ['m', 'a', 'ng', '_', '_']
				{'string': 'm/a/ng/_/_', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				ANALYSING: mange
					resolving (1)
					> version: m/a/ng/e
					RESULT:  ['_']
				adding dashed alternative: ['m', 'a', 'ng', 'e', '_']
				m/a/ng/e(CVCV)
m/a/ng/e/_(CVCVA)
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm/a/ng/e', 'rgx': '((m))/((a))/((n)|(ng))/((e))/((_))$'}
				_____REMOVING________['m', 'a', 'ng', 'e']
				version split: ['m', 'a', 'ng', 'e', '_']
				{'string': 'm/a/ng/e/_', 'rgx': '((m))/((a))/((n)|(ng))/((e))/((_))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n/_
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_', '_']
				m/o/n/_(CVCA)
m/o/n/_/_(CVCAA)
				version split: ['m', 'o', 'n', '_']
				{'string': 'm/o/n/_', 'rgx': '((m))/((o))/((n))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', '_']
				version split: ['m', 'o', 'n', '_', '_']
				{'string': 'm/o/n/_/_', 'rgx': '((m))/((o))/((n))/((_))/((_))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/_/g
					TRYING: g
					adding blocked set: C = C >> g, _, s
					> version: m/o/ng/_
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_', '_', 'g']
				adding dashed alternative: ['m', 'o', 'ng', '_', '_']
				m/o/n/_/g(CVCAC)
m/o/ng/_(CVCA)
m/o/n/_/_/g(CVCAAC)
m/o/ng/_/_(CVCAA)
				version split: ['m', 'o', 'n', '_', 'g']
				{'string': 'm/o/n/_/g', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', '_', 'g']
				version split: ['m', 'o', 'ng', '_']
				{'string': 'm/o/ng/_', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'ng', '_']
				version split: ['m', 'o', 'n', '_', '_', 'g']
				{'string': 'm/o/n/_/_/g', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', '_', '_', 'g']
				version split: ['m', 'o', 'ng', '_', '_']
				{'string': 'm/o/ng/_/_', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				ANALYSING: monge
					resolving (1)
					> version: m/o/ng/e
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'ng', 'e', '_']
				m/o/ng/e(CVCV)
m/o/ng/e/_(CVCVA)
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm/o/ng/e', 'rgx': '((m))/((o))/((n)|(ng))/((e))/((_))$'}
				_____REMOVING________['m', 'o', 'ng', 'e']
				version split: ['m', 'o', 'ng', 'e', '_']
				{'string': 'm/o/ng/e/_', 'rgx': '((m))/((o))/((n)|(ng))/((e))/((_))$'}
		FAIL: 
		FAIL: 
		only one version left: ['m', '_', '_', '_', '_']
		only one version left: ['m', 'a', 'ng', '_', '_']
		only one version left: ['m', 'a', 'ng', 'e', '_']
		only one version left: ['m', 'o', 'n', '_', '_']
		only one version left: ['m', 'o', 'ng', '_', '_']
		only one version left: ['m', 'o', 'ng', 'e', '_']
		SPLIT: ['m', 'a', 'ng', 'i', 's']
		SPLIT: ["['_']", "['a']", "['_']", "['_']", "['_']"]
		SPLIT: ['m', '_', '_', '_', '_']
		['m', '_', '_', '_', '_']
		SPLIT: ['m', 'a', 'ng', '_', '_']
		['m', 'a', 'ng', '_', '_']
		SPLIT: ['m', 'a', 'ng', 'e', '_']
		['m', 'a', 'ng', 'e', '_']
		SPLIT: ['m', 'o', 'n', '_', '_']
		['m', 'o', 'n', '_', '_']
		SPLIT: ['m', 'o', 'ng', '_', '_']
		['m', 'o', 'ng', '_', '_']
		SPLIT: ['m', 'o', 'ng', 'e', '_']
		['m', 'o', 'ng', 'e', '_']
		version for pattern CVCVC is INVALID
		[]
		1
		OVERVIEW: version for pattern CVCVC

faulty splits: 1
['']['a'][''][''][''] <-! among
m | a | ng | i | s
['_'] | ['a'] | ['_'] | ['_'] | ['_']
m | _ | _ | _ | _
m | a | ng | _ | _
m | a | ng | e | _
m | o | n | _ | _
m | o | ng | _ | _
m | o | ng | e | _
2 : {'m', 'ng'},{'m', 'ng'}
4 : {'g', '_', 's'},{'m', 's'},{'m', 's'},{'g', '_', 's'}
	[[{'lit': 'ng', 'ln': 2, 'index': 3}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	MIN pattern length=5
	Pattern CVCVC is valid
	Pattern CVCCV is valid
	Pattern CVCCVC is valid
	Pattern CVCV is invalid
	Pattern CVCCC is valid
	Pattern CVCC is invalid
	Pattern VCVCC is valid
	Pattern VCVC is invalid
	Pattern CVC is invalid
	Pattern C is invalid
	Pattern CVCCCC is invalid
	Making the selection for pattern: CVCCV
	Selection for pattern: CVCCV completed
	Making a version for pattern: CVCCV
			___CVCCV : 0___
				ANALYSING: mange
				adding littera based on matching pattern
				ANALYSING: monge
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: a/m/o/n/g
					TRYING: a
					> version: a/m/o/ng
					TRYING: a
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', 'm', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', 'm', 'o', 'ng']
				a/m/o/n/g(VCVCC)
a/m/o/ng(VCVC)
_/a/m/o/n/g(AVCVCC)
_/a/m/o/ng(AVCVC)
				version split: ['a', 'm', 'o', 'n', 'g']
				{'string': 'a', 'rgx': '((_))$'}
				_____REMOVING________['a', 'm', 'o', 'n', 'g']
				version split: ['a', 'm', 'o', 'ng']
				{'string': 'a', 'rgx': '((_))$'}
				_____REMOVING________['a', 'm', 'o', 'ng']
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_', 'rgx': '((_))$'}
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_', 'rgx': '((_))$'}
				ANALYSING: m
					resolving (1)
					> version: m
					TRYING: m
					RESULT:  ['m']
				version split: ['m']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: m
					> version: m/a/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mangis
					resolving (4)
					> version: m/a/n/g/i/s
					TRYING: m
					> version: m/a/n/g/i/s
					TRYING: m
					> version: m/a/ng/i/s
					TRYING: m
					> version: m/a/ng/i/s
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'a', 'ng', 'i', 's']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'a', 'ng', 'i', 's']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'o', 'n']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: m
					> version: m/o/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm', 'rgx': '((m))$'}
			___CVCCV : 1___
				ANALYSING: mange
				adding littera based on matching pattern
				ANALYSING: monge
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/o/n/g
					TRYING: a
					> version: _/a/m/o/ng
					TRYING: a
					RESULT:  ['a']
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_/a', 'rgx': '((_))/((a))$'}
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_/a', 'rgx': '((_))/((a))$'}
				ANALYSING: m
					resolving (1)
					> version: m
					RESULT:  ['_']
				adding dashed alternative: ['m', '_']
				m(C)
m/_(CA)
				version split: ['m']
				{'string': 'm', 'rgx': '((m))/((_))$'}
				_____REMOVING________['m']
				version split: ['m', '_']
				{'string': 'm/_', 'rgx': '((m))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: a
					> version: m/a/ng
					TRYING: a
					RESULT:  ['a']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				ANALYSING: mangis
					resolving (4)
					> version: m/a/n/g/i/s
					TRYING: a
					> version: m/a/n/g/i/s
					TRYING: a
					> version: m/a/ng/i/s
					TRYING: a
					> version: m/a/ng/i/s
					TRYING: a
					RESULT:  ['a']
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				version split: ['m', 'a', 'ng', 'i', 's']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				version split: ['m', 'a', 'ng', 'i', 's']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: o
					RESULT:  ['o']
				version split: ['m', 'o', 'n']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: o
					> version: m/o/ng
					TRYING: o
					RESULT:  ['o']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
			___CVCCV : 2___
				ANALYSING: mange
				adding littera based on matching pattern
				ANALYSING: monge
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/o/n/g
					TRYING: m
					> version: _/a/m/o/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_/a/m', 'rgx': '((_))/((a))/((m))$'}
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_/a/m', 'rgx': '((_))/((a))/((m))$'}
				ANALYSING: m
					resolving (1)
					> version: m/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_']
				m/_(CA)
m/_/_(CAA)
				version split: ['m', '_']
				{'string': 'm/_', 'rgx': '((m))/((_))/((_))$'}
				_____REMOVING________['m', '_']
				version split: ['m', '_', '_']
				{'string': 'm/_/_', 'rgx': '((m))/((_))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: n
					> version: m/a/ng
					TRYING: ng
					adding blocked set: C = C >> m, n, _, ng
					RESULT:  ['n']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a/n', 'rgx': '((m))/((a))/((n))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm/a/ng', 'rgx': '((m))/((a))/((n))$'}
				_____REMOVING________['m', 'a', 'ng']
				ANALYSING: mangis
					resolving (4)
					> version: m/a/n/g/i/s
					TRYING: n
					> version: m/a/n/g/i/s
					TRYING: n
					> version: m/a/ng/i/s
					TRYING: ng
					adding blocked set: C = C >> m, n, _, ng
					> version: m/a/ng/i/s
					TRYING: ng
					adding blocked set: C = C >> m, n, _, ng
					RESULT:  ['n']
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm/a/n', 'rgx': '((m))/((a))/((n))$'}
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm/a/n', 'rgx': '((m))/((a))/((n))$'}
				version split: ['m', 'a', 'ng', 'i', 's']
				{'string': 'm/a/ng', 'rgx': '((m))/((a))/((n))$'}
				_____REMOVING________['m', 'a', 'ng', 'i', 's']
				version split: ['m', 'a', 'ng', 'i', 's']
				{'string': 'm/a/ng', 'rgx': '((m))/((a))/((n))$'}
				_____REMOVING________['m', 'a', 'ng', 'i', 's']
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: n
					RESULT:  ['n']
				version split: ['m', 'o', 'n']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: n
					> version: m/o/ng
					TRYING: ng
					adding blocked set: C = C >> m, n, _, ng
					RESULT:  ['n']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm/o/ng', 'rgx': '((m))/((o))/((n))$'}
				_____REMOVING________['m', 'o', 'ng']
			___CVCCV : 3___
				ANALYSING: mange
				adding littera based on matching pattern
				ANALYSING: monge
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/o/n/g
					TRYING: o
					> version: _/a/m/o/ng
					TRYING: o
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', 'm', '_', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', 'm', '_', 'o', 'ng']
				_/a/m/o/n/g(AVCVCC)
_/a/m/o/ng(AVCVC)
_/a/m/_/o/n/g(AVCAVCC)
_/a/m/_/o/ng(AVCAVC)
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_/a/m/o', 'rgx': '((_))/((a))/((m))/((_))$'}
				_____REMOVING________['_', 'a', 'm', 'o', 'n', 'g']
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_/a/m/o', 'rgx': '((_))/((a))/((m))/((_))$'}
				_____REMOVING________['_', 'a', 'm', 'o', 'ng']
				version split: ['_', 'a', 'm', '_', 'o', 'n', 'g']
				{'string': '_/a/m/_', 'rgx': '((_))/((a))/((m))/((_))$'}
				version split: ['_', 'a', 'm', '_', 'o', 'ng']
				{'string': '_/a/m/_', 'rgx': '((_))/((a))/((m))/((_))$'}
				ANALYSING: m
					resolving (1)
					> version: m/_/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_', '_']
				m/_/_(CAA)
m/_/_/_(CAAA)
				version split: ['m', '_', '_']
				{'string': 'm/_/_', 'rgx': '((m))/((_))/((_))/((_))$'}
				_____REMOVING________['m', '_', '_']
				version split: ['m', '_', '_', '_']
				{'string': 'm/_/_/_', 'rgx': '((m))/((_))/((_))/((_))$'}
				ANALYSING: mang
					resolving (1)
					> version: m/a/n/g
					TRYING: g
					RESULT:  ['g']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a/n/g', 'rgx': '((m))/((a))/((n))/((g))$'}
				ANALYSING: mangis
					resolving (2)
					> version: m/a/n/g/i/s
					TRYING: g
					> version: m/a/n/g/i/s
					TRYING: g
					RESULT:  ['g']
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm/a/n/g', 'rgx': '((m))/((a))/((n))/((g))$'}
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm/a/n/g', 'rgx': '((m))/((a))/((n))/((g))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_']
				m/o/n(CVC)
m/o/n/_(CVCA)
				version split: ['m', 'o', 'n']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n))/((_))$'}
				_____REMOVING________['m', 'o', 'n']
				version split: ['m', 'o', 'n', '_']
				{'string': 'm/o/n/_', 'rgx': '((m))/((o))/((n))/((_))$'}
				ANALYSING: mong
					resolving (1)
					> version: m/o/n/g
					TRYING: g
					RESULT:  ['g']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o/n/g', 'rgx': '((m))/((o))/((n))/((g))$'}
			___CVCCV : 4___
				ANALYSING: mange
				adding littera based on matching pattern
				ANALYSING: monge
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/_/o/n/g
					TRYING: o
					> version: _/a/m/_/o/ng
					TRYING: o
					RESULT:  ['o']
				version split: ['_', 'a', 'm', '_', 'o', 'n', 'g']
				{'string': '_/a/m/_/o/n', 'rgx': '((_))/((a))/((m))/((_))/((o))$'}
				_____REMOVING________['_', 'a', 'm', '_', 'o', 'n', 'g']
				version split: ['_', 'a', 'm', '_', 'o', 'ng']
				{'string': '_/a/m/_/o/ng', 'rgx': '((_))/((a))/((m))/((_))/((o))$'}
				_____REMOVING________['_', 'a', 'm', '_', 'o', 'ng']
				ANALYSING: m
					resolving (1)
					> version: m/_/_/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_', '_', '_']
				m/_/_/_(CAAA)
m/_/_/_/_(CAAAA)
				version split: ['m', '_', '_', '_']
				{'string': 'm/_/_/_', 'rgx': '((m))/((_))/((_))/((_))/((_))$'}
				_____REMOVING________['m', '_', '_', '_']
				version split: ['m', '_', '_', '_', '_']
				{'string': 'm/_/_/_/_', 'rgx': '((m))/((_))/((_))/((_))/((_))$'}
				ANALYSING: mang
					resolving (1)
					> version: m/a/n/g
					RESULT:  ['_']
				adding dashed alternative: ['m', 'a', 'n', 'g', '_']
				m/a/n/g(CVCC)
m/a/n/g/_(CVCCA)
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a/n/g', 'rgx': '((m))/((a))/((n))/((g))/((_))$'}
				_____REMOVING________['m', 'a', 'n', 'g']
				version split: ['m', 'a', 'n', 'g', '_']
				{'string': 'm/a/n/g/_', 'rgx': '((m))/((a))/((n))/((g))/((_))$'}
				ANALYSING: mangis
					resolving (2)
					> version: m/a/n/g/i/s
					TRYING: i
					> version: m/a/n/g/i/s
					TRYING: i
					RESULT:  ['i']
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm/a/n/g/i/s', 'rgx': '((m))/((a))/((n))/((g))/((i))$'}
				_____REMOVING________['m', 'a', 'n', 'g', 'i', 's']
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm/a/n/g/i/s', 'rgx': '((m))/((a))/((n))/((g))/((i))$'}
				_____REMOVING________['m', 'a', 'n', 'g', 'i', 's']
				ANALYSING: mon
					resolving (1)
					> version: m/o/n/_
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_', '_']
				m/o/n/_(CVCA)
m/o/n/_/_(CVCAA)
				version split: ['m', 'o', 'n', '_']
				{'string': 'm/o/n/_', 'rgx': '((m))/((o))/((n))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', '_']
				version split: ['m', 'o', 'n', '_', '_']
				{'string': 'm/o/n/_/_', 'rgx': '((m))/((o))/((n))/((_))/((_))$'}
				ANALYSING: mong
					resolving (1)
					> version: m/o/n/g
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', 'g', '_']
				m/o/n/g(CVCC)
m/o/n/g/_(CVCCA)
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o/n/g', 'rgx': '((m))/((o))/((n))/((g))/((_))$'}
				_____REMOVING________['m', 'o', 'n', 'g']
				version split: ['m', 'o', 'n', 'g', '_']
				{'string': 'm/o/n/g/_', 'rgx': '((m))/((o))/((n))/((g))/((_))$'}
		FAIL: 
		FAIL: 
		FAIL: 
		only one version left: ['m', '_', '_', '_', '_']
		only one version left: ['m', 'a', 'n', 'g', '_']
		FAIL: 
		only one version left: ['m', 'o', 'n', '_', '_']
		only one version left: ['m', 'o', 'n', 'g', '_']
		SPLIT: ['m', 'a', 'n', 'g', 'e']
		SPLIT: ['m', 'o', 'n', 'g', 'e']
		SPLIT: ["['_']", "['a']", "['m']", "['_']", "['o']"]
		SPLIT: ['m', '_', '_', '_', '_']
		['m', '_', '_', '_', '_']
		SPLIT: ['m', 'a', 'n', 'g', '_']
		['m', 'a', 'n', 'g', '_']
		SPLIT: ["['m']", "['a']", "['n']", "['g']", "['i']"]
		SPLIT: ['m', 'o', 'n', '_', '_']
		['m', 'o', 'n', '_', '_']
		SPLIT: ['m', 'o', 'n', 'g', '_']
		['m', 'o', 'n', 'g', '_']
		version for pattern CVCCV is INVALID
		[]
		2
		OVERVIEW: version for pattern CVCCV

faulty splits: 2
['']['a']['m']['']['o'] <-! among
['m']['a']['n']['g']['i'] <-! mangis
m | a | n | g | e
m | o | n | g | e
['_'] | ['a'] | ['m'] | ['_'] | ['o']
m | _ | _ | _ | _
m | a | n | g | _
['m'] | ['a'] | ['n'] | ['g'] | ['i']
m | o | n | _ | _
m | o | n | g | _
	[[{'lit': 'ng', 'ln': 2, 'index': 3}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	MIN pattern length=5
	Pattern CVCVC is valid
	Pattern CVCCV is valid
	Pattern CVCCVC is valid
	Pattern CVCV is invalid
	Pattern CVCCC is valid
	Pattern CVCC is invalid
	Pattern VCVCC is valid
	Pattern VCVC is invalid
	Pattern CVC is invalid
	Pattern C is invalid
	Pattern CVCCCC is invalid
	Making the selection for pattern: CVCCVC
	Selection for pattern: CVCCVC completed
	Making a version for pattern: CVCCVC
			___CVCCVC : 0___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: a/m/o/n/g
					TRYING: a
					> version: a/m/o/ng
					TRYING: a
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', 'm', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', 'm', 'o', 'ng']
				a/m/o/n/g(VCVCC)
a/m/o/ng(VCVC)
_/a/m/o/n/g(AVCVCC)
_/a/m/o/ng(AVCVC)
				version split: ['a', 'm', 'o', 'n', 'g']
				{'string': 'a', 'rgx': '((_))$'}
				_____REMOVING________['a', 'm', 'o', 'n', 'g']
				version split: ['a', 'm', 'o', 'ng']
				{'string': 'a', 'rgx': '((_))$'}
				_____REMOVING________['a', 'm', 'o', 'ng']
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_', 'rgx': '((_))$'}
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_', 'rgx': '((_))$'}
				ANALYSING: m
					resolving (1)
					> version: m
					TRYING: m
					RESULT:  ['m']
				version split: ['m']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: m
					> version: m/a/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: m
					> version: m/a/ng/e
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'o', 'n']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: m
					> version: m/o/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: m
					> version: m/o/ng/e
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm', 'rgx': '((m))$'}
			___CVCCVC : 1___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/o/n/g
					TRYING: a
					> version: _/a/m/o/ng
					TRYING: a
					RESULT:  ['a']
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_/a', 'rgx': '((_))/((a))$'}
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_/a', 'rgx': '((_))/((a))$'}
				ANALYSING: m
					resolving (1)
					> version: m
					RESULT:  ['_']
				adding dashed alternative: ['m', '_']
				m(C)
m/_(CA)
				version split: ['m']
				{'string': 'm', 'rgx': '((m))/((_))$'}
				_____REMOVING________['m']
				version split: ['m', '_']
				{'string': 'm/_', 'rgx': '((m))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: a
					> version: m/a/ng
					TRYING: a
					RESULT:  ['a']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: a
					> version: m/a/ng/e
					TRYING: a
					RESULT:  ['a']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: o
					RESULT:  ['o']
				version split: ['m', 'o', 'n']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: o
					> version: m/o/ng
					TRYING: o
					RESULT:  ['o']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: o
					> version: m/o/ng/e
					TRYING: o
					RESULT:  ['o']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
			___CVCCVC : 2___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/o/n/g
					TRYING: m
					> version: _/a/m/o/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_/a/m', 'rgx': '((_))/((a))/((m))$'}
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_/a/m', 'rgx': '((_))/((a))/((m))$'}
				ANALYSING: m
					resolving (1)
					> version: m/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_']
				m/_(CA)
m/_/_(CAA)
				version split: ['m', '_']
				{'string': 'm/_', 'rgx': '((m))/((_))/((_))$'}
				_____REMOVING________['m', '_']
				version split: ['m', '_', '_']
				{'string': 'm/_/_', 'rgx': '((m))/((_))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: n
					> version: m/a/ng
					TRYING: ng
					adding blocked set: C = C >> m, n, _, ng
					RESULT:  ['n']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a/n', 'rgx': '((m))/((a))/((n))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm/a/ng', 'rgx': '((m))/((a))/((n))$'}
				_____REMOVING________['m', 'a', 'ng']
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: n
					> version: m/a/ng/e
					TRYING: ng
					adding blocked set: C = C >> m, n, _, ng
					RESULT:  ['n']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm/a/n', 'rgx': '((m))/((a))/((n))$'}
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm/a/ng', 'rgx': '((m))/((a))/((n))$'}
				_____REMOVING________['m', 'a', 'ng', 'e']
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: n
					RESULT:  ['n']
				version split: ['m', 'o', 'n']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: n
					> version: m/o/ng
					TRYING: ng
					adding blocked set: C = C >> m, n, _, ng
					RESULT:  ['n']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm/o/ng', 'rgx': '((m))/((o))/((n))$'}
				_____REMOVING________['m', 'o', 'ng']
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: n
					> version: m/o/ng/e
					TRYING: ng
					adding blocked set: C = C >> m, n, _, ng
					RESULT:  ['n']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n))$'}
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm/o/ng', 'rgx': '((m))/((o))/((n))$'}
				_____REMOVING________['m', 'o', 'ng', 'e']
			___CVCCVC : 3___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/o/n/g
					TRYING: o
					> version: _/a/m/o/ng
					TRYING: o
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', 'm', '_', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', 'm', '_', 'o', 'ng']
				_/a/m/o/n/g(AVCVCC)
_/a/m/o/ng(AVCVC)
_/a/m/_/o/n/g(AVCAVCC)
_/a/m/_/o/ng(AVCAVC)
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_/a/m/o', 'rgx': '((_))/((a))/((m))/((_))$'}
				_____REMOVING________['_', 'a', 'm', 'o', 'n', 'g']
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_/a/m/o', 'rgx': '((_))/((a))/((m))/((_))$'}
				_____REMOVING________['_', 'a', 'm', 'o', 'ng']
				version split: ['_', 'a', 'm', '_', 'o', 'n', 'g']
				{'string': '_/a/m/_', 'rgx': '((_))/((a))/((m))/((_))$'}
				version split: ['_', 'a', 'm', '_', 'o', 'ng']
				{'string': '_/a/m/_', 'rgx': '((_))/((a))/((m))/((_))$'}
				ANALYSING: m
					resolving (1)
					> version: m/_/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_', '_']
				m/_/_(CAA)
m/_/_/_(CAAA)
				version split: ['m', '_', '_']
				{'string': 'm/_/_', 'rgx': '((m))/((_))/((_))/((_))$'}
				_____REMOVING________['m', '_', '_']
				version split: ['m', '_', '_', '_']
				{'string': 'm/_/_/_', 'rgx': '((m))/((_))/((_))/((_))$'}
				ANALYSING: mang
					resolving (1)
					> version: m/a/n/g
					TRYING: g
					RESULT:  ['g']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a/n/g', 'rgx': '((m))/((a))/((n))/((g))$'}
				ANALYSING: mange
					resolving (1)
					> version: m/a/n/g/e
					TRYING: g
					RESULT:  ['g']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm/a/n/g', 'rgx': '((m))/((a))/((n))/((g))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_']
				m/o/n(CVC)
m/o/n/_(CVCA)
				version split: ['m', 'o', 'n']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n))/((_))$'}
				_____REMOVING________['m', 'o', 'n']
				version split: ['m', 'o', 'n', '_']
				{'string': 'm/o/n/_', 'rgx': '((m))/((o))/((n))/((_))$'}
				ANALYSING: mong
					resolving (1)
					> version: m/o/n/g
					TRYING: g
					RESULT:  ['g']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o/n/g', 'rgx': '((m))/((o))/((n))/((g))$'}
				ANALYSING: monge
					resolving (1)
					> version: m/o/n/g/e
					TRYING: g
					RESULT:  ['g']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm/o/n/g', 'rgx': '((m))/((o))/((n))/((g))$'}
			___CVCCVC : 4___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/_/o/n/g
					TRYING: o
					> version: _/a/m/_/o/ng
					TRYING: o
					RESULT:  ['o']
				version split: ['_', 'a', 'm', '_', 'o', 'n', 'g']
				{'string': '_/a/m/_/o', 'rgx': '((_))/((a))/((m))/((_))/((o))$'}
				version split: ['_', 'a', 'm', '_', 'o', 'ng']
				{'string': '_/a/m/_/o', 'rgx': '((_))/((a))/((m))/((_))/((o))$'}
				ANALYSING: m
					resolving (1)
					> version: m/_/_/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_', '_', '_']
				m/_/_/_(CAAA)
m/_/_/_/_(CAAAA)
				version split: ['m', '_', '_', '_']
				{'string': 'm/_/_/_', 'rgx': '((m))/((_))/((_))/((_))/((_))$'}
				_____REMOVING________['m', '_', '_', '_']
				version split: ['m', '_', '_', '_', '_']
				{'string': 'm/_/_/_/_', 'rgx': '((m))/((_))/((_))/((_))/((_))$'}
				ANALYSING: mang
					resolving (1)
					> version: m/a/n/g
					RESULT:  ['_']
				adding dashed alternative: ['m', 'a', 'n', 'g', '_']
				m/a/n/g(CVCC)
m/a/n/g/_(CVCCA)
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a/n/g', 'rgx': '((m))/((a))/((n))/((g))/((_))$'}
				_____REMOVING________['m', 'a', 'n', 'g']
				version split: ['m', 'a', 'n', 'g', '_']
				{'string': 'm/a/n/g/_', 'rgx': '((m))/((a))/((n))/((g))/((_))$'}
				ANALYSING: mange
					resolving (1)
					> version: m/a/n/g/e
					TRYING: e
					RESULT:  ['e']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm/a/n/g/e', 'rgx': '((m))/((a))/((n))/((g))/((e))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n/_
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_', '_']
				m/o/n/_(CVCA)
m/o/n/_/_(CVCAA)
				version split: ['m', 'o', 'n', '_']
				{'string': 'm/o/n/_', 'rgx': '((m))/((o))/((n))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', '_']
				version split: ['m', 'o', 'n', '_', '_']
				{'string': 'm/o/n/_/_', 'rgx': '((m))/((o))/((n))/((_))/((_))$'}
				ANALYSING: mong
					resolving (1)
					> version: m/o/n/g
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', 'g', '_']
				m/o/n/g(CVCC)
m/o/n/g/_(CVCCA)
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o/n/g', 'rgx': '((m))/((o))/((n))/((g))/((_))$'}
				_____REMOVING________['m', 'o', 'n', 'g']
				version split: ['m', 'o', 'n', 'g', '_']
				{'string': 'm/o/n/g/_', 'rgx': '((m))/((o))/((n))/((g))/((_))$'}
				ANALYSING: monge
					resolving (1)
					> version: m/o/n/g/e
					TRYING: e
					RESULT:  ['e']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm/o/n/g/e', 'rgx': '((m))/((o))/((n))/((g))/((e))$'}
			___CVCCVC : 5___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/_/o/n/g
					TRYING: n
					> version: _/a/m/_/o/ng
					TRYING: ng
					adding blocked set: C = C >> s, ng
					RESULT:  ['n']
				version split: ['_', 'a', 'm', '_', 'o', 'n', 'g']
				{'string': '_/a/m/_/o/n/g', 'rgx': '((_))/((a))/((m))/((_))/((o))/((n))$'}
				_____REMOVING________['_', 'a', 'm', '_', 'o', 'n', 'g']
				version split: ['_', 'a', 'm', '_', 'o', 'ng']
				{'string': '_/a/m/_/o/ng', 'rgx': '((_))/((a))/((m))/((_))/((o))/((n))$'}
				_____REMOVING________['_', 'a', 'm', '_', 'o', 'ng']
				ANALYSING: m
					resolving (1)
					> version: m/_/_/_/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_', '_', '_', '_']
				m/_/_/_/_(CAAAA)
m/_/_/_/_/_(CAAAAA)
				version split: ['m', '_', '_', '_', '_']
				{'string': 'm/_/_/_/_', 'rgx': '((m))/((_))/((_))/((_))/((_))/((_))$'}
				_____REMOVING________['m', '_', '_', '_', '_']
				version split: ['m', '_', '_', '_', '_', '_']
				{'string': 'm/_/_/_/_/_', 'rgx': '((m))/((_))/((_))/((_))/((_))/((_))$'}
				ANALYSING: mang
					resolving (1)
					> version: m/a/n/g/_
					RESULT:  ['_']
				adding dashed alternative: ['m', 'a', 'n', 'g', '_', '_']
				m/a/n/g/_(CVCCA)
m/a/n/g/_/_(CVCCAA)
				version split: ['m', 'a', 'n', 'g', '_']
				{'string': 'm/a/n/g/_', 'rgx': '((m))/((a))/((n))/((g))/((_))/((_))$'}
				_____REMOVING________['m', 'a', 'n', 'g', '_']
				version split: ['m', 'a', 'n', 'g', '_', '_']
				{'string': 'm/a/n/g/_/_', 'rgx': '((m))/((a))/((n))/((g))/((_))/((_))$'}
				ANALYSING: mange
					resolving (1)
					> version: m/a/n/g/e
					RESULT:  ['_']
				adding dashed alternative: ['m', 'a', 'n', 'g', 'e', '_']
				m/a/n/g/e(CVCCV)
m/a/n/g/e/_(CVCCVA)
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm/a/n/g/e', 'rgx': '((m))/((a))/((n))/((g))/((e))/((_))$'}
				_____REMOVING________['m', 'a', 'n', 'g', 'e']
				version split: ['m', 'a', 'n', 'g', 'e', '_']
				{'string': 'm/a/n/g/e/_', 'rgx': '((m))/((a))/((n))/((g))/((e))/((_))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n/_/_
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_', '_', '_']
				m/o/n/_/_(CVCAA)
m/o/n/_/_/_(CVCAAA)
				version split: ['m', 'o', 'n', '_', '_']
				{'string': 'm/o/n/_/_', 'rgx': '((m))/((o))/((n))/((_))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', '_', '_']
				version split: ['m', 'o', 'n', '_', '_', '_']
				{'string': 'm/o/n/_/_/_', 'rgx': '((m))/((o))/((n))/((_))/((_))/((_))$'}
				ANALYSING: mong
					resolving (1)
					> version: m/o/n/g/_
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', 'g', '_', '_']
				m/o/n/g/_(CVCCA)
m/o/n/g/_/_(CVCCAA)
				version split: ['m', 'o', 'n', 'g', '_']
				{'string': 'm/o/n/g/_', 'rgx': '((m))/((o))/((n))/((g))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', 'g', '_']
				version split: ['m', 'o', 'n', 'g', '_', '_']
				{'string': 'm/o/n/g/_/_', 'rgx': '((m))/((o))/((n))/((g))/((_))/((_))$'}
				ANALYSING: monge
					resolving (1)
					> version: m/o/n/g/e
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', 'g', 'e', '_']
				m/o/n/g/e(CVCCV)
m/o/n/g/e/_(CVCCVA)
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm/o/n/g/e', 'rgx': '((m))/((o))/((n))/((g))/((e))/((_))$'}
				_____REMOVING________['m', 'o', 'n', 'g', 'e']
				version split: ['m', 'o', 'n', 'g', 'e', '_']
				{'string': 'm/o/n/g/e/_', 'rgx': '((m))/((o))/((n))/((g))/((e))/((_))$'}
		FAIL: 
		FAIL: 
		only one version left: ['m', '_', '_', '_', '_', '_']
		only one version left: ['m', 'a', 'n', 'g', '_', '_']
		only one version left: ['m', 'a', 'n', 'g', 'e', '_']
		only one version left: ['m', 'o', 'n', '_', '_', '_']
		only one version left: ['m', 'o', 'n', 'g', '_', '_']
		only one version left: ['m', 'o', 'n', 'g', 'e', '_']
		SPLIT: ['m', 'a', 'n', 'g', 'i', 's']
		SPLIT: ["['_']", "['a']", "['m']", "['_']", "['o']", "['n']"]
		SPLIT: ['m', '_', '_', '_', '_', '_']
		['m', '_', '_', '_', '_', '_']
		SPLIT: ['m', 'a', 'n', 'g', '_', '_']
		['m', 'a', 'n', 'g', '_', '_']
		SPLIT: ['m', 'a', 'n', 'g', 'e', '_']
		['m', 'a', 'n', 'g', 'e', '_']
		SPLIT: ['m', 'o', 'n', '_', '_', '_']
		['m', 'o', 'n', '_', '_', '_']
		SPLIT: ['m', 'o', 'n', 'g', '_', '_']
		['m', 'o', 'n', 'g', '_', '_']
		SPLIT: ['m', 'o', 'n', 'g', 'e', '_']
		['m', 'o', 'n', 'g', 'e', '_']
		version for pattern CVCCVC is INVALID
		[]
		1
		OVERVIEW: version for pattern CVCCVC

faulty splits: 1
['']['a']['m']['']['o']['n'] <-! among
m | a | n | g | i | s
['_'] | ['a'] | ['m'] | ['_'] | ['o'] | ['n']
m | _ | _ | _ | _ | _
m | a | n | g | _ | _
m | a | n | g | e | _
m | o | n | _ | _ | _
m | o | n | g | _ | _
m | o | n | g | e | _
	[[{'lit': 'ng', 'ln': 2, 'index': 3}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	MIN pattern length=5
	Pattern CVCVC is valid
	Pattern CVCCV is valid
	Pattern CVCCVC is valid
	Pattern CVCV is invalid
	Pattern CVCCC is valid
	Pattern CVCC is invalid
	Pattern VCVCC is valid
	Pattern VCVC is invalid
	Pattern CVC is invalid
	Pattern C is invalid
	Pattern CVCCCC is invalid
	Making the selection for pattern: CVCCC
	Selection for pattern: CVCCC completed
	Making a version for pattern: CVCCC
			___CVCCC : 0___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: a/m/o/n/g
					TRYING: a
					> version: a/m/o/ng
					TRYING: a
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', 'm', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', 'm', 'o', 'ng']
				a/m/o/n/g(VCVCC)
a/m/o/ng(VCVC)
_/a/m/o/n/g(AVCVCC)
_/a/m/o/ng(AVCVC)
				version split: ['a', 'm', 'o', 'n', 'g']
				{'string': 'a', 'rgx': '((_))$'}
				_____REMOVING________['a', 'm', 'o', 'n', 'g']
				version split: ['a', 'm', 'o', 'ng']
				{'string': 'a', 'rgx': '((_))$'}
				_____REMOVING________['a', 'm', 'o', 'ng']
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_', 'rgx': '((_))$'}
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_', 'rgx': '((_))$'}
				ANALYSING: m
					resolving (1)
					> version: m
					TRYING: m
					RESULT:  ['m']
				version split: ['m']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: m
					> version: m/a/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: m
					> version: m/a/ng/e
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'o', 'n']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: m
					> version: m/o/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm', 'rgx': '((m))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: m
					> version: m/o/ng/e
					TRYING: m
					RESULT:  ['m']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm', 'rgx': '((m))$'}
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm', 'rgx': '((m))$'}
			___CVCCC : 1___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/o/n/g
					TRYING: a
					> version: _/a/m/o/ng
					TRYING: a
					RESULT:  ['a']
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_/a', 'rgx': '((_))/((a))$'}
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_/a', 'rgx': '((_))/((a))$'}
				ANALYSING: m
					resolving (1)
					> version: m
					RESULT:  ['_']
				adding dashed alternative: ['m', '_']
				m(C)
m/_(CA)
				version split: ['m']
				{'string': 'm', 'rgx': '((m))/((_))$'}
				_____REMOVING________['m']
				version split: ['m', '_']
				{'string': 'm/_', 'rgx': '((m))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: a
					> version: m/a/ng
					TRYING: a
					RESULT:  ['a']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: a
					> version: m/a/ng/e
					TRYING: a
					RESULT:  ['a']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm/a', 'rgx': '((m))/((a))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: o
					RESULT:  ['o']
				version split: ['m', 'o', 'n']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: o
					> version: m/o/ng
					TRYING: o
					RESULT:  ['o']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: o
					> version: m/o/ng/e
					TRYING: o
					RESULT:  ['o']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm/o', 'rgx': '((m))/((o))$'}
			___CVCCC : 2___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/m/o/n/g
					TRYING: m
					adding blocked set: C = C >> m, ng
					> version: _/a/m/o/ng
					TRYING: m
					adding blocked set: C = C >> m, ng
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', '_', 'm', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', '_', 'm', 'o', 'ng']
				_/a/m/o/n/g(AVCVCC)
_/a/m/o/ng(AVCVC)
_/a/_/m/o/n/g(AVACVCC)
_/a/_/m/o/ng(AVACVC)
				version split: ['_', 'a', 'm', 'o', 'n', 'g']
				{'string': '_/a/m', 'rgx': '((_))/((a))/((_))$'}
				_____REMOVING________['_', 'a', 'm', 'o', 'n', 'g']
				version split: ['_', 'a', 'm', 'o', 'ng']
				{'string': '_/a/m', 'rgx': '((_))/((a))/((_))$'}
				_____REMOVING________['_', 'a', 'm', 'o', 'ng']
				version split: ['_', 'a', '_', 'm', 'o', 'n', 'g']
				{'string': '_/a/_', 'rgx': '((_))/((a))/((_))$'}
				version split: ['_', 'a', '_', 'm', 'o', 'ng']
				{'string': '_/a/_', 'rgx': '((_))/((a))/((_))$'}
				ANALYSING: m
					resolving (1)
					> version: m/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_']
				m/_(CA)
m/_/_(CAA)
				version split: ['m', '_']
				{'string': 'm/_', 'rgx': '((m))/((_))/((_))$'}
				_____REMOVING________['m', '_']
				version split: ['m', '_', '_']
				{'string': 'm/_/_', 'rgx': '((m))/((_))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: n
					> version: m/a/ng
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a/n', 'rgx': '((m))/((a))/((n)|(ng))$'}
				version split: ['m', 'a', 'ng']
				{'string': 'm/a/ng', 'rgx': '((m))/((a))/((n)|(ng))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: n
					> version: m/a/ng/e
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm/a/n', 'rgx': '((m))/((a))/((n)|(ng))$'}
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm/a/ng', 'rgx': '((m))/((a))/((n)|(ng))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: n
					RESULT:  ['n']
				version split: ['m', 'o', 'n']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: n
					> version: m/o/ng
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n)|(ng))$'}
				version split: ['m', 'o', 'ng']
				{'string': 'm/o/ng', 'rgx': '((m))/((o))/((n)|(ng))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: n
					> version: m/o/ng/e
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n)|(ng))$'}
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm/o/ng', 'rgx': '((m))/((o))/((n)|(ng))$'}
			___CVCCC : 3___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/_/m/o/n/g
					TRYING: m
					adding blocked set: C = C >> m, i
					> version: _/a/_/m/o/ng
					TRYING: m
					adding blocked set: C = C >> m, i
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', '_', '_', 'm', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', '_', '_', 'm', 'o', 'ng']
				_/a/_/m/o/n/g(AVACVCC)
_/a/_/m/o/ng(AVACVC)
_/a/_/_/m/o/n/g(AVAACVCC)
_/a/_/_/m/o/ng(AVAACVC)
				version split: ['_', 'a', '_', 'm', 'o', 'n', 'g']
				{'string': '_/a/_/m', 'rgx': '((_))/((a))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', 'm', 'o', 'n', 'g']
				version split: ['_', 'a', '_', 'm', 'o', 'ng']
				{'string': '_/a/_/m', 'rgx': '((_))/((a))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', 'm', 'o', 'ng']
				version split: ['_', 'a', '_', '_', 'm', 'o', 'n', 'g']
				{'string': '_/a/_/_', 'rgx': '((_))/((a))/((_))/((_))$'}
				version split: ['_', 'a', '_', '_', 'm', 'o', 'ng']
				{'string': '_/a/_/_', 'rgx': '((_))/((a))/((_))/((_))$'}
				ANALYSING: m
					resolving (1)
					> version: m/_/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_', '_']
				m/_/_(CAA)
m/_/_/_(CAAA)
				version split: ['m', '_', '_']
				{'string': 'm/_/_', 'rgx': '((m))/((_))/((_))/((_))$'}
				_____REMOVING________['m', '_', '_']
				version split: ['m', '_', '_', '_']
				{'string': 'm/_/_/_', 'rgx': '((m))/((_))/((_))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: g
					adding blocked set: C = C >> g, _, i
					> version: m/a/ng
					RESULT:  ['_']
				adding dashed alternative: ['m', 'a', 'n', '_', 'g']
				adding dashed alternative: ['m', 'a', 'ng', '_']
				m/a/n/g(CVCC)
m/a/ng(CVC)
m/a/n/_/g(CVCAC)
m/a/ng/_(CVCA)
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm/a/n/g', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'a', 'n', 'g']
				version split: ['m', 'a', 'ng']
				{'string': 'm/a/ng', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'a', 'ng']
				version split: ['m', 'a', 'n', '_', 'g']
				{'string': 'm/a/n/_', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				version split: ['m', 'a', 'ng', '_']
				{'string': 'm/a/ng/_', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: g
					adding blocked set: C = C >> g, _, i
					> version: m/a/ng/e
					TRYING: e
					RESULT:  ['_']
				adding dashed alternative: ['m', 'a', 'n', '_', 'g', 'e']
				adding dashed alternative: ['m', 'a', 'ng', '_', 'e']
				m/a/n/g/e(CVCCV)
m/a/ng/e(CVCV)
m/a/n/_/g/e(CVCACV)
m/a/ng/_/e(CVCAV)
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm/a/n/g', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'a', 'n', 'g', 'e']
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm/a/ng/e', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'a', 'ng', 'e']
				version split: ['m', 'a', 'n', '_', 'g', 'e']
				{'string': 'm/a/n/_', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				version split: ['m', 'a', 'ng', '_', 'e']
				{'string': 'm/a/ng/_', 'rgx': '((m))/((a))/((n)|(ng))/((_))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_']
				m/o/n(CVC)
m/o/n/_(CVCA)
				version split: ['m', 'o', 'n']
				{'string': 'm/o/n', 'rgx': '((m))/((o))/((n))/((_))$'}
				_____REMOVING________['m', 'o', 'n']
				version split: ['m', 'o', 'n', '_']
				{'string': 'm/o/n/_', 'rgx': '((m))/((o))/((n))/((_))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: g
					adding blocked set: C = C >> g, _, i
					> version: m/o/ng
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_', 'g']
				adding dashed alternative: ['m', 'o', 'ng', '_']
				m/o/n/g(CVCC)
m/o/ng(CVC)
m/o/n/_/g(CVCAC)
m/o/ng/_(CVCA)
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm/o/n/g', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'o', 'n', 'g']
				version split: ['m', 'o', 'ng']
				{'string': 'm/o/ng', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'o', 'ng']
				version split: ['m', 'o', 'n', '_', 'g']
				{'string': 'm/o/n/_', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
				version split: ['m', 'o', 'ng', '_']
				{'string': 'm/o/ng/_', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: g
					adding blocked set: C = C >> g, _, i
					> version: m/o/ng/e
					TRYING: e
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_', 'g', 'e']
				adding dashed alternative: ['m', 'o', 'ng', '_', 'e']
				m/o/n/g/e(CVCCV)
m/o/ng/e(CVCV)
m/o/n/_/g/e(CVCACV)
m/o/ng/_/e(CVCAV)
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm/o/n/g', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'o', 'n', 'g', 'e']
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm/o/ng/e', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
				_____REMOVING________['m', 'o', 'ng', 'e']
				version split: ['m', 'o', 'n', '_', 'g', 'e']
				{'string': 'm/o/n/_', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
				version split: ['m', 'o', 'ng', '_', 'e']
				{'string': 'm/o/ng/_', 'rgx': '((m))/((o))/((n)|(ng))/((_))$'}
			___CVCCC : 4___
				ANALYSING: mangis
				adding littera based on matching pattern
				ANALYSING: among
					resolving (2)
					> version: _/a/_/_/m/o/n/g
					TRYING: m
					adding blocked set: C = C >> m, s
					> version: _/a/_/_/m/o/ng
					TRYING: m
					adding blocked set: C = C >> m, s
					RESULT:  ['_']
				adding dashed alternative: ['_', 'a', '_', '_', '_', 'm', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'a', '_', '_', '_', 'm', 'o', 'ng']
				_/a/_/_/m/o/n/g(AVAACVCC)
_/a/_/_/m/o/ng(AVAACVC)
_/a/_/_/_/m/o/n/g(AVAAACVCC)
_/a/_/_/_/m/o/ng(AVAAACVC)
				version split: ['_', 'a', '_', '_', 'm', 'o', 'n', 'g']
				{'string': '_/a/_/_/m/o', 'rgx': '((_))/((a))/((_))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', '_', 'm', 'o', 'n', 'g']
				version split: ['_', 'a', '_', '_', 'm', 'o', 'ng']
				{'string': '_/a/_/_/m/o', 'rgx': '((_))/((a))/((_))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', '_', 'm', 'o', 'ng']
				version split: ['_', 'a', '_', '_', '_', 'm', 'o', 'n', 'g']
				{'string': '_/a/_/_/_/m', 'rgx': '((_))/((a))/((_))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', '_', '_', 'm', 'o', 'n', 'g']
				version split: ['_', 'a', '_', '_', '_', 'm', 'o', 'ng']
				{'string': '_/a/_/_/_/m', 'rgx': '((_))/((a))/((_))/((_))/((_))$'}
				_____REMOVING________['_', 'a', '_', '_', '_', 'm', 'o', 'ng']
				ANALYSING: m
					resolving (1)
					> version: m/_/_/_
					RESULT:  ['_']
				adding dashed alternative: ['m', '_', '_', '_', '_']
				m/_/_/_(CAAA)
m/_/_/_/_(CAAAA)
				version split: ['m', '_', '_', '_']
				{'string': 'm/_/_/_', 'rgx': '((m))/((_))/((_))/((_))/((_))$'}
				_____REMOVING________['m', '_', '_', '_']
				version split: ['m', '_', '_', '_', '_']
				{'string': 'm/_/_/_/_', 'rgx': '((m))/((_))/((_))/((_))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/_/g
					TRYING: g
					adding blocked set: C = C >> g, _, s
					> version: m/a/ng/_
					RESULT:  ['_']
				adding dashed alternative: ['m', 'a', 'n', '_', '_', 'g']
				adding dashed alternative: ['m', 'a', 'ng', '_', '_']
				m/a/n/_/g(CVCAC)
m/a/ng/_(CVCA)
m/a/n/_/_/g(CVCAAC)
m/a/ng/_/_(CVCAA)
				version split: ['m', 'a', 'n', '_', 'g']
				{'string': 'm/a/n/_/g', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'a', 'n', '_', 'g']
				version split: ['m', 'a', 'ng', '_']
				{'string': 'm/a/ng/_', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'a', 'ng', '_']
				version split: ['m', 'a', 'n', '_', '_', 'g']
				{'string': 'm/a/n/_/_/g', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'a', 'n', '_', '_', 'g']
				version split: ['m', 'a', 'ng', '_', '_']
				{'string': 'm/a/ng/_/_', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/_/g/e
					TRYING: g
					adding blocked set: C = C >> g, _, s
					> version: m/a/ng/_/e
					TRYING: e
					RESULT:  ['_']
				adding dashed alternative: ['m', 'a', 'n', '_', '_', 'g', 'e']
				adding dashed alternative: ['m', 'a', 'ng', '_', '_', 'e']
				m/a/n/_/g/e(CVCACV)
m/a/ng/_/e(CVCAV)
m/a/n/_/_/g/e(CVCAACV)
m/a/ng/_/_/e(CVCAAV)
				version split: ['m', 'a', 'n', '_', 'g', 'e']
				{'string': 'm/a/n/_/g/e', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'a', 'n', '_', 'g', 'e']
				version split: ['m', 'a', 'ng', '_', 'e']
				{'string': 'm/a/ng/_/e', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'a', 'ng', '_', 'e']
				version split: ['m', 'a', 'n', '_', '_', 'g', 'e']
				{'string': 'm/a/n/_/_/g', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'a', 'n', '_', '_', 'g', 'e']
				version split: ['m', 'a', 'ng', '_', '_', 'e']
				{'string': 'm/a/ng/_/_/e', 'rgx': '((m))/((a))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'a', 'ng', '_', '_', 'e']
				ANALYSING: mon
					resolving (1)
					> version: m/o/n/_
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_', '_']
				m/o/n/_(CVCA)
m/o/n/_/_(CVCAA)
				version split: ['m', 'o', 'n', '_']
				{'string': 'm/o/n/_', 'rgx': '((m))/((o))/((n))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', '_']
				version split: ['m', 'o', 'n', '_', '_']
				{'string': 'm/o/n/_/_', 'rgx': '((m))/((o))/((n))/((_))/((_))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/_/g
					TRYING: g
					adding blocked set: C = C >> g, _, s
					> version: m/o/ng/_
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_', '_', 'g']
				adding dashed alternative: ['m', 'o', 'ng', '_', '_']
				m/o/n/_/g(CVCAC)
m/o/ng/_(CVCA)
m/o/n/_/_/g(CVCAAC)
m/o/ng/_/_(CVCAA)
				version split: ['m', 'o', 'n', '_', 'g']
				{'string': 'm/o/n/_/g', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', '_', 'g']
				version split: ['m', 'o', 'ng', '_']
				{'string': 'm/o/ng/_', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'ng', '_']
				version split: ['m', 'o', 'n', '_', '_', 'g']
				{'string': 'm/o/n/_/_/g', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', '_', '_', 'g']
				version split: ['m', 'o', 'ng', '_', '_']
				{'string': 'm/o/ng/_/_', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/_/g/e
					TRYING: g
					adding blocked set: C = C >> g, _, s
					> version: m/o/ng/_/e
					TRYING: e
					RESULT:  ['_']
				adding dashed alternative: ['m', 'o', 'n', '_', '_', 'g', 'e']
				adding dashed alternative: ['m', 'o', 'ng', '_', '_', 'e']
				m/o/n/_/g/e(CVCACV)
m/o/ng/_/e(CVCAV)
m/o/n/_/_/g/e(CVCAACV)
m/o/ng/_/_/e(CVCAAV)
				version split: ['m', 'o', 'n', '_', 'g', 'e']
				{'string': 'm/o/n/_/g/e', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', '_', 'g', 'e']
				version split: ['m', 'o', 'ng', '_', 'e']
				{'string': 'm/o/ng/_/e', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'ng', '_', 'e']
				version split: ['m', 'o', 'n', '_', '_', 'g', 'e']
				{'string': 'm/o/n/_/_/g', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'n', '_', '_', 'g', 'e']
				version split: ['m', 'o', 'ng', '_', '_', 'e']
				{'string': 'm/o/ng/_/_/e', 'rgx': '((m))/((o))/((n)|(ng))/((_))/((_))$'}
				_____REMOVING________['m', 'o', 'ng', '_', '_', 'e']
		FAIL: 
		FAIL: 
		only one version left: ['m', '_', '_', '_', '_']
		only one version left: ['m', 'a', 'ng', '_', '_']
		FAIL: 
		only one version left: ['m', 'o', 'n', '_', '_']
		only one version left: ['m', 'o', 'ng', '_', '_']
		FAIL: 
		SPLIT: ['m', 'a', 'ng', 'i', 's']
		SPLIT: ["['_']", "['a']", "['_']", "['_']", "['_']"]
		SPLIT: ['m', '_', '_', '_', '_']
		['m', '_', '_', '_', '_']
		SPLIT: ['m', 'a', 'ng', '_', '_']
		['m', 'a', 'ng', '_', '_']
		SPLIT: ["['m']", "['a']", "['n', 'ng']", "['_']", "['_']"]
		SPLIT: ['m', 'o', 'n', '_', '_']
		['m', 'o', 'n', '_', '_']
		SPLIT: ['m', 'o', 'ng', '_', '_']
		['m', 'o', 'ng', '_', '_']
		SPLIT: ["['m']", "['o']", "['n', 'ng']", "['_']", "['_']"]
		version for pattern CVCCC is INVALID
		[]
		3
		OVERVIEW: version for pattern CVCCC

faulty splits: 3
['']['a'][''][''][''] <-! among
['m']['a']['n', 'ng'][''][''] <-! mange
['m']['o']['n', 'ng'][''][''] <-! monge
m | a | ng | i | s
['_'] | ['a'] | ['_'] | ['_'] | ['_']
m | _ | _ | _ | _
m | a | ng | _ | _
['m'] | ['a'] | ['n', 'ng'] | ['_'] | ['_']
m | o | n | _ | _
m | o | ng | _ | _
['m'] | ['o'] | ['n', 'ng'] | ['_'] | ['_']
2 : {'m', 'ng'},{'m', 'ng'}
3 : {'g', '_', 'i'},{'g', '_', 'i'},{'m', 'i'},{'g', '_', 'i'},{'m', 'i'},{'g', '_', 'i'}
4 : {'m', 's'},{'g', '_', 's'},{'m', 's'},{'g', '_', 's'},{'g', '_', 's'},{'g', '_', 's'}
	[[{'lit': 'ng', 'ln': 2, 'index': 3}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ng', 'ln': 2, 'index': 2}]]
	MIN pattern length=5
	Pattern CVCVC is valid
	Pattern CVCCV is valid
	Pattern CVCCVC is valid
	Pattern CVCV is invalid
	Pattern CVCCC is valid
	Pattern CVCC is invalid
	Pattern VCVCC is valid
	Pattern VCVC is invalid
	Pattern CVC is invalid
	Pattern C is invalid
	Pattern CVCCCC is invalid
	Making the selection for pattern: VCVCC
	Selection for pattern: VCVCC completed
	Making a version for pattern: VCVCC
			___VCVCC : 0___
				ANALYSING: among
				adding littera based on matching pattern
				ANALYSING: m
					resolving (1)
					> version: m
					TRYING: m
					RESULT:  ['_']
				adding dashed alternative: ['_', 'm']
				m(C)
_/m(AC)
				version split: ['m']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m']
				version split: ['_', 'm']
				{'string': '_', 'rgx': '((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: m/a/n/g
					TRYING: m
					> version: m/a/ng
					TRYING: m
					RESULT:  ['_']
				adding dashed alternative: ['_', 'm', 'a', 'n', 'g']
				adding dashed alternative: ['_', 'm', 'a', 'ng']
				m/a/n/g(CVCC)
m/a/ng(CVC)
_/m/a/n/g(ACVCC)
_/m/a/ng(ACVC)
				version split: ['m', 'a', 'n', 'g']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'a', 'n', 'g']
				version split: ['m', 'a', 'ng']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'a', 'ng']
				version split: ['_', 'm', 'a', 'n', 'g']
				{'string': '_', 'rgx': '((_))$'}
				version split: ['_', 'm', 'a', 'ng']
				{'string': '_', 'rgx': '((_))$'}
				ANALYSING: mange
					resolving (2)
					> version: m/a/n/g/e
					TRYING: m
					> version: m/a/ng/e
					TRYING: m
					RESULT:  ['_']
				adding dashed alternative: ['_', 'm', 'a', 'n', 'g', 'e']
				adding dashed alternative: ['_', 'm', 'a', 'ng', 'e']
				m/a/n/g/e(CVCCV)
m/a/ng/e(CVCV)
_/m/a/n/g/e(ACVCCV)
_/m/a/ng/e(ACVCV)
				version split: ['m', 'a', 'n', 'g', 'e']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'a', 'n', 'g', 'e']
				version split: ['m', 'a', 'ng', 'e']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'a', 'ng', 'e']
				version split: ['_', 'm', 'a', 'n', 'g', 'e']
				{'string': '_', 'rgx': '((_))$'}
				version split: ['_', 'm', 'a', 'ng', 'e']
				{'string': '_', 'rgx': '((_))$'}
				ANALYSING: mangis
					resolving (4)
					> version: m/a/n/g/i/s
					TRYING: m
					> version: m/a/n/g/i/s
					TRYING: m
					> version: m/a/ng/i/s
					TRYING: m
					> version: m/a/ng/i/s
					TRYING: m
					RESULT:  ['_']
				adding dashed alternative: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				adding dashed alternative: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				adding dashed alternative: ['_', 'm', 'a', 'ng', 'i', 's']
				adding dashed alternative: ['_', 'm', 'a', 'ng', 'i', 's']
				m/a/n/g/i/s(CVCCCC)
m/a/n/g/i/s(CVCCVC)
m/a/ng/i/s(CVCCC)
m/a/ng/i/s(CVCVC)
_/m/a/n/g/i/s(ACVCCAC)
_/m/a/n/g/i/s(ACVCCAC)
_/m/a/ng/i/s(ACVCAC)
_/m/a/ng/i/s(ACVCAC)
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'a', 'n', 'g', 'i', 's']
				version split: ['m', 'a', 'n', 'g', 'i', 's']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'a', 'n', 'g', 'i', 's']
				version split: ['m', 'a', 'ng', 'i', 's']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'a', 'ng', 'i', 's']
				version split: ['m', 'a', 'ng', 'i', 's']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'a', 'ng', 'i', 's']
				version split: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				{'string': '_', 'rgx': '((_))$'}
				version split: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				{'string': '_', 'rgx': '((_))$'}
				version split: ['_', 'm', 'a', 'ng', 'i', 's']
				{'string': '_', 'rgx': '((_))$'}
				version split: ['_', 'm', 'a', 'ng', 'i', 's']
				{'string': '_', 'rgx': '((_))$'}
				ANALYSING: mon
					resolving (1)
					> version: m/o/n
					TRYING: m
					RESULT:  ['_']
				adding dashed alternative: ['_', 'm', 'o', 'n']
				m/o/n(CVC)
_/m/o/n(ACVC)
				version split: ['m', 'o', 'n']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'o', 'n']
				version split: ['_', 'm', 'o', 'n']
				{'string': '_', 'rgx': '((_))$'}
				ANALYSING: mong
					resolving (2)
					> version: m/o/n/g
					TRYING: m
					> version: m/o/ng
					TRYING: m
					RESULT:  ['_']
				adding dashed alternative: ['_', 'm', 'o', 'n', 'g']
				adding dashed alternative: ['_', 'm', 'o', 'ng']
				m/o/n/g(CVCC)
m/o/ng(CVC)
_/m/o/n/g(ACVCC)
_/m/o/ng(ACVC)
				version split: ['m', 'o', 'n', 'g']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'o', 'n', 'g']
				version split: ['m', 'o', 'ng']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'o', 'ng']
				version split: ['_', 'm', 'o', 'n', 'g']
				{'string': '_', 'rgx': '((_))$'}
				version split: ['_', 'm', 'o', 'ng']
				{'string': '_', 'rgx': '((_))$'}
				ANALYSING: monge
					resolving (2)
					> version: m/o/n/g/e
					TRYING: m
					> version: m/o/ng/e
					TRYING: m
					RESULT:  ['_']
				adding dashed alternative: ['_', 'm', 'o', 'n', 'g', 'e']
				adding dashed alternative: ['_', 'm', 'o', 'ng', 'e']
				m/o/n/g/e(CVCCV)
m/o/ng/e(CVCV)
_/m/o/n/g/e(ACVCCV)
_/m/o/ng/e(ACVCV)
				version split: ['m', 'o', 'n', 'g', 'e']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'o', 'n', 'g', 'e']
				version split: ['m', 'o', 'ng', 'e']
				{'string': 'm', 'rgx': '((_))$'}
				_____REMOVING________['m', 'o', 'ng', 'e']
				version split: ['_', 'm', 'o', 'n', 'g', 'e']
				{'string': '_', 'rgx': '((_))$'}
				version split: ['_', 'm', 'o', 'ng', 'e']
				{'string': '_', 'rgx': '((_))$'}
			___VCVCC : 1___
				ANALYSING: among
				adding littera based on matching pattern
				ANALYSING: m
					resolving (1)
					> version: _/m
					TRYING: m
					RESULT:  ['m']
				version split: ['_', 'm']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				ANALYSING: mang
					resolving (2)
					> version: _/m/a/n/g
					TRYING: m
					> version: _/m/a/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['_', 'm', 'a', 'n', 'g']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				version split: ['_', 'm', 'a', 'ng']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				ANALYSING: mange
					resolving (2)
					> version: _/m/a/n/g/e
					TRYING: m
					> version: _/m/a/ng/e
					TRYING: m
					RESULT:  ['m']
				version split: ['_', 'm', 'a', 'n', 'g', 'e']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				version split: ['_', 'm', 'a', 'ng', 'e']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				ANALYSING: mangis
					resolving (4)
					> version: _/m/a/n/g/i/s
					TRYING: m
					> version: _/m/a/n/g/i/s
					TRYING: m
					> version: _/m/a/ng/i/s
					TRYING: m
					> version: _/m/a/ng/i/s
					TRYING: m
					RESULT:  ['m']
				version split: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				version split: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				version split: ['_', 'm', 'a', 'ng', 'i', 's']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				version split: ['_', 'm', 'a', 'ng', 'i', 's']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				ANALYSING: mon
					resolving (1)
					> version: _/m/o/n
					TRYING: m
					RESULT:  ['m']
				version split: ['_', 'm', 'o', 'n']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				ANALYSING: mong
					resolving (2)
					> version: _/m/o/n/g
					TRYING: m
					> version: _/m/o/ng
					TRYING: m
					RESULT:  ['m']
				version split: ['_', 'm', 'o', 'n', 'g']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				version split: ['_', 'm', 'o', 'ng']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				ANALYSING: monge
					resolving (2)
					> version: _/m/o/n/g/e
					TRYING: m
					> version: _/m/o/ng/e
					TRYING: m
					RESULT:  ['m']
				version split: ['_', 'm', 'o', 'n', 'g', 'e']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
				version split: ['_', 'm', 'o', 'ng', 'e']
				{'string': '_/m', 'rgx': '((_))/((m))$'}
			___VCVCC : 2___
				ANALYSING: among
				adding littera based on matching pattern
				ANALYSING: m
					resolving (1)
					> version: _/m
					RESULT:  ['_']
				adding dashed alternative: ['_', 'm', '_']
				_/m(AC)
_/m/_(ACA)
				version split: ['_', 'm']
				{'string': '_/m', 'rgx': '((_))/((m))/((_))$'}
				_____REMOVING________['_', 'm']
				version split: ['_', 'm', '_']
				{'string': '_/m/_', 'rgx': '((_))/((m))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: _/m/a/n/g
					TRYING: a
					> version: _/m/a/ng
					TRYING: a
					RESULT:  ['a']
				version split: ['_', 'm', 'a', 'n', 'g']
				{'string': '_/m/a', 'rgx': '((_))/((m))/((a))$'}
				version split: ['_', 'm', 'a', 'ng']
				{'string': '_/m/a', 'rgx': '((_))/((m))/((a))$'}
				ANALYSING: mange
					resolving (2)
					> version: _/m/a/n/g/e
					TRYING: a
					> version: _/m/a/ng/e
					TRYING: a
					RESULT:  ['a']
				version split: ['_', 'm', 'a', 'n', 'g', 'e']
				{'string': '_/m/a', 'rgx': '((_))/((m))/((a))$'}
				version split: ['_', 'm', 'a', 'ng', 'e']
				{'string': '_/m/a', 'rgx': '((_))/((m))/((a))$'}
				ANALYSING: mangis
					resolving (4)
					> version: _/m/a/n/g/i/s
					TRYING: a
					> version: _/m/a/n/g/i/s
					TRYING: a
					> version: _/m/a/ng/i/s
					TRYING: a
					> version: _/m/a/ng/i/s
					TRYING: a
					RESULT:  ['a']
				version split: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				{'string': '_/m/a', 'rgx': '((_))/((m))/((a))$'}
				version split: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				{'string': '_/m/a', 'rgx': '((_))/((m))/((a))$'}
				version split: ['_', 'm', 'a', 'ng', 'i', 's']
				{'string': '_/m/a', 'rgx': '((_))/((m))/((a))$'}
				version split: ['_', 'm', 'a', 'ng', 'i', 's']
				{'string': '_/m/a', 'rgx': '((_))/((m))/((a))$'}
				ANALYSING: mon
					resolving (1)
					> version: _/m/o/n
					TRYING: o
					RESULT:  ['o']
				version split: ['_', 'm', 'o', 'n']
				{'string': '_/m/o', 'rgx': '((_))/((m))/((o))$'}
				ANALYSING: mong
					resolving (2)
					> version: _/m/o/n/g
					TRYING: o
					> version: _/m/o/ng
					TRYING: o
					RESULT:  ['o']
				version split: ['_', 'm', 'o', 'n', 'g']
				{'string': '_/m/o', 'rgx': '((_))/((m))/((o))$'}
				version split: ['_', 'm', 'o', 'ng']
				{'string': '_/m/o', 'rgx': '((_))/((m))/((o))$'}
				ANALYSING: monge
					resolving (2)
					> version: _/m/o/n/g/e
					TRYING: o
					> version: _/m/o/ng/e
					TRYING: o
					RESULT:  ['o']
				version split: ['_', 'm', 'o', 'n', 'g', 'e']
				{'string': '_/m/o', 'rgx': '((_))/((m))/((o))$'}
				version split: ['_', 'm', 'o', 'ng', 'e']
				{'string': '_/m/o', 'rgx': '((_))/((m))/((o))$'}
			___VCVCC : 3___
				ANALYSING: among
				adding littera based on matching pattern
				ANALYSING: m
					resolving (1)
					> version: _/m/_
					RESULT:  ['_']
				adding dashed alternative: ['_', 'm', '_', '_']
				_/m/_(ACA)
_/m/_/_(ACAA)
				version split: ['_', 'm', '_']
				{'string': '_/m/_', 'rgx': '((_))/((m))/((_))/((_))$'}
				_____REMOVING________['_', 'm', '_']
				version split: ['_', 'm', '_', '_']
				{'string': '_/m/_/_', 'rgx': '((_))/((m))/((_))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: _/m/a/n/g
					TRYING: n
					> version: _/m/a/ng
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['_', 'm', 'a', 'n', 'g']
				{'string': '_/m/a/n', 'rgx': '((_))/((m))/((a))/((n)|(ng))$'}
				version split: ['_', 'm', 'a', 'ng']
				{'string': '_/m/a/ng', 'rgx': '((_))/((m))/((a))/((n)|(ng))$'}
				ANALYSING: mange
					resolving (2)
					> version: _/m/a/n/g/e
					TRYING: n
					> version: _/m/a/ng/e
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['_', 'm', 'a', 'n', 'g', 'e']
				{'string': '_/m/a/n', 'rgx': '((_))/((m))/((a))/((n)|(ng))$'}
				version split: ['_', 'm', 'a', 'ng', 'e']
				{'string': '_/m/a/ng', 'rgx': '((_))/((m))/((a))/((n)|(ng))$'}
				ANALYSING: mangis
					resolving (4)
					> version: _/m/a/n/g/i/s
					TRYING: n
					> version: _/m/a/n/g/i/s
					TRYING: n
					> version: _/m/a/ng/i/s
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					> version: _/m/a/ng/i/s
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				{'string': '_/m/a/n', 'rgx': '((_))/((m))/((a))/((n)|(ng))$'}
				version split: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				{'string': '_/m/a/n', 'rgx': '((_))/((m))/((a))/((n)|(ng))$'}
				version split: ['_', 'm', 'a', 'ng', 'i', 's']
				{'string': '_/m/a/ng', 'rgx': '((_))/((m))/((a))/((n)|(ng))$'}
				version split: ['_', 'm', 'a', 'ng', 'i', 's']
				{'string': '_/m/a/ng', 'rgx': '((_))/((m))/((a))/((n)|(ng))$'}
				ANALYSING: mon
					resolving (1)
					> version: _/m/o/n
					TRYING: n
					RESULT:  ['n']
				version split: ['_', 'm', 'o', 'n']
				{'string': '_/m/o/n', 'rgx': '((_))/((m))/((o))/((n))$'}
				ANALYSING: mong
					resolving (2)
					> version: _/m/o/n/g
					TRYING: n
					> version: _/m/o/ng
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['_', 'm', 'o', 'n', 'g']
				{'string': '_/m/o/n', 'rgx': '((_))/((m))/((o))/((n)|(ng))$'}
				version split: ['_', 'm', 'o', 'ng']
				{'string': '_/m/o/ng', 'rgx': '((_))/((m))/((o))/((n)|(ng))$'}
				ANALYSING: monge
					resolving (2)
					> version: _/m/o/n/g/e
					TRYING: n
					> version: _/m/o/ng/e
					TRYING: ng
					>>> MULTIPLE RESOLVE OPTIONS: {'n', 'ng'}
					RESULT:  ['n', 'ng']
				version split: ['_', 'm', 'o', 'n', 'g', 'e']
				{'string': '_/m/o/n', 'rgx': '((_))/((m))/((o))/((n)|(ng))$'}
				version split: ['_', 'm', 'o', 'ng', 'e']
				{'string': '_/m/o/ng', 'rgx': '((_))/((m))/((o))/((n)|(ng))$'}
			___VCVCC : 4___
				ANALYSING: among
				adding littera based on matching pattern
				ANALYSING: m
					resolving (1)
					> version: _/m/_/_
					RESULT:  ['_']
				adding dashed alternative: ['_', 'm', '_', '_', '_']
				_/m/_/_(ACAA)
_/m/_/_/_(ACAAA)
				version split: ['_', 'm', '_', '_']
				{'string': '_/m/_/_', 'rgx': '((_))/((m))/((_))/((_))/((_))$'}
				_____REMOVING________['_', 'm', '_', '_']
				version split: ['_', 'm', '_', '_', '_']
				{'string': '_/m/_/_/_', 'rgx': '((_))/((m))/((_))/((_))/((_))$'}
				ANALYSING: mang
					resolving (2)
					> version: _/m/a/n/g
					TRYING: g
					> version: _/m/a/ng
					RESULT:  ['g']
				version split: ['_', 'm', 'a', 'n', 'g']
				{'string': '_/m/a/n/g', 'rgx': '((_))/((m))/((a))/((n)|(ng))/((g))$'}
				version split: ['_', 'm', 'a', 'ng']
				{'string': '_/m/a/ng', 'rgx': '((_))/((m))/((a))/((n)|(ng))/((g))$'}
				_____REMOVING________['_', 'm', 'a', 'ng']
				ANALYSING: mange
					resolving (2)
					> version: _/m/a/n/g/e
					TRYING: g
					> version: _/m/a/ng/e
					TRYING: e
					RESULT:  ['g']
				version split: ['_', 'm', 'a', 'n', 'g', 'e']
				{'string': '_/m/a/n/g/e', 'rgx': '((_))/((m))/((a))/((n)|(ng))/((g))$'}
				_____REMOVING________['_', 'm', 'a', 'n', 'g', 'e']
				version split: ['_', 'm', 'a', 'ng', 'e']
				{'string': '_/m/a/ng/e', 'rgx': '((_))/((m))/((a))/((n)|(ng))/((g))$'}
				_____REMOVING________['_', 'm', 'a', 'ng', 'e']
				ANALYSING: mangis
					resolving (4)
					> version: _/m/a/n/g/i/s
					TRYING: g
					> version: _/m/a/n/g/i/s
					TRYING: g
					> version: _/m/a/ng/i/s
					TRYING: i
					adding blocked set: C = C >> g, _, i
					> version: _/m/a/ng/i/s
					TRYING: i
					adding blocked set: C = C >> g, _, i
					RESULT:  ['g']
				version split: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				{'string': '_/m/a/n/g/i', 'rgx': '((_))/((m))/((a))/((n)|(ng))/((g))$'}
				_____REMOVING________['_', 'm', 'a', 'n', 'g', 'i', 's']
				version split: ['_', 'm', 'a', 'n', 'g', 'i', 's']
				{'string': '_/m/a/n/g/i', 'rgx': '((_))/((m))/((a))/((n)|(ng))/((g))$'}
				_____REMOVING________['_', 'm', 'a', 'n', 'g', 'i', 's']
				version split: ['_', 'm', 'a', 'ng', 'i', 's']
				{'string': '_/m/a/ng/i/s', 'rgx': '((_))/((m))/((a))/((n)|(ng))/((g))$'}
				_____REMOVING________['_', 'm', 'a', 'ng', 'i', 's']
				version split: ['_', 'm', 'a', 'ng', 'i', 's']
				{'string': '_/m/a/ng/i/s', 'rgx': '((_))/((m))/((a))/((n)|(ng))/((g))$'}
				_____REMOVING________['_', 'm', 'a', 'ng', 'i', 's']
				ANALYSING: mon
					resolving (1)
					> version: _/m/o/n
					RESULT:  ['_']
				adding dashed alternative: ['_', 'm', 'o', 'n', '_']
				_/m/o/n(ACVC)
_/m/o/n/_(ACVCA)
				version split: ['_', 'm', 'o', 'n']
				{'string': '_/m/o/n', 'rgx': '((_))/((m))/((o))/((n))/((_))$'}
				_____REMOVING________['_', 'm', 'o', 'n']
				version split: ['_', 'm', 'o', 'n', '_']
				{'string': '_/m/o/n/_', 'rgx': '((_))/((m))/((o))/((n))/((_))$'}
				ANALYSING: mong
					resolving (2)
					> version: _/m/o/n/g
					TRYING: g
					> version: _/m/o/ng
					RESULT:  ['g']
				version split: ['_', 'm', 'o', 'n', 'g']
				{'string': '_/m/o/n/g', 'rgx': '((_))/((m))/((o))/((n)|(ng))/((g))$'}
				version split: ['_', 'm', 'o', 'ng']
				{'string': '_/m/o/ng', 'rgx': '((_))/((m))/((o))/((n)|(ng))/((g))$'}
				_____REMOVING________['_', 'm', 'o', 'ng']
				ANALYSING: monge
					resolving (2)
					> version: _/m/o/n/g/e
					TRYING: g
					> version: _/m/o/ng/e
					TRYING: e
					RESULT:  ['g']
				version split: ['_', 'm', 'o', 'n', 'g', 'e']
				{'string': '_/m/o/n/g/e', 'rgx': '((_))/((m))/((o))/((n)|(ng))/((g))$'}
				_____REMOVING________['_', 'm', 'o', 'n', 'g', 'e']
				version split: ['_', 'm', 'o', 'ng', 'e']
				{'string': '_/m/o/ng/e', 'rgx': '((_))/((m))/((o))/((n)|(ng))/((g))$'}
				_____REMOVING________['_', 'm', 'o', 'ng', 'e']
		FAIL: 
		only one version left: ['_', 'm', '_', '_', '_']
		only one version left: ['_', 'm', 'a', 'n', 'g']
		FAIL: 
		FAIL: 
		only one version left: ['_', 'm', 'o', 'n', '_']
		only one version left: ['_', 'm', 'o', 'n', 'g']
		FAIL: 
		SPLIT: ['a', 'm', 'o', 'n', 'g']
		SPLIT: ['_', 'm', '_', '_', '_']
		['_', 'm', '_', '_', '_']
		SPLIT: ['_', 'm', 'a', 'n', 'g']
		['_', 'm', 'a', 'n', 'g']
		SPLIT: ["['_']", "['m']", "['a']", "['n', 'ng']", "['g']"]
		SPLIT: ["['_']", "['m']", "['a']", "['n', 'ng']", "['g']"]
		SPLIT: ['_', 'm', 'o', 'n', '_']
		['_', 'm', 'o', 'n', '_']
		SPLIT: ['_', 'm', 'o', 'n', 'g']
		['_', 'm', 'o', 'n', 'g']
		SPLIT: ["['_']", "['m']", "['o']", "['n', 'ng']", "['g']"]
		version for pattern VCVCC is INVALID
		[]
		3
		OVERVIEW: version for pattern VCVCC

faulty splits: 3
['']['m']['a']['n', 'ng']['g'] <-! mange
['']['m']['a']['n', 'ng']['g'] <-! mangis
['']['m']['o']['n', 'ng']['g'] <-! monge
a | m | o | n | g
_ | m | _ | _ | _
_ | m | a | n | g
['_'] | ['m'] | ['a'] | ['n', 'ng'] | ['g']
['_'] | ['m'] | ['a'] | ['n', 'ng'] | ['g']
_ | m | o | n | _
_ | m | o | n | g
['_'] | ['m'] | ['o'] | ['n', 'ng'] | ['g']
	FOUND __ 0 __ VALID VERSION(S)
	OVERVIEW: version for pattern CVCVC

faulty splits: 1
['']['a'][''][''][''] <-! among
m | a | ng | i | s
['_'] | ['a'] | ['_'] | ['_'] | ['_']
m | _ | _ | _ | _
m | a | ng | _ | _
m | a | ng | e | _
m | o | n | _ | _
m | o | ng | _ | _
m | o | ng | e | _
2 : {'m', 'ng'},{'m', 'ng'}
4 : {'g', '_', 's'},{'m', 's'},{'m', 's'},{'g', '_', 's'}
	{'CVCCCV', 'CCVCCC', 'CVCCCVC', 'VCCVCC', 'CCVCCV', 'CCVCCVC', 'CVCVCC', 'CVCCCC', 'CCVCVC'}
