Analysis object initialized
{'sæg': 2, 'sæi': 1, 'sai': 62, 'saþ': 1, 'say': 45, 'seg': 21, 'segg': 214, 'sei': 41, 'seiȝ': 1, 'seugg': 1, 'sey': 10, 'si': 1, 'sig': 3, 'sigg': 47, 'sucg': 1, 'sug': 8, 'sugg': 18, 'svgg': 1, 'zigg': 60, 'zygg': 5}
Lexel initialized
[[{'lit': 'ai', 'ln': 2, 'index': 1}]]
[[{'lit': 'ay', 'ln': 2, 'index': 1}]]
[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
[[{'lit': 'ei', 'ln': 2, 'index': 1}]]
[[{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}]]
[[{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}, {'lit': 'ey', 'ln': 2, 'index': 1}]]
[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
MIN pattern length=3
Pattern CCC is valid
Pattern CVV is valid
Pattern CV is invalid
Pattern CVCC is valid
Pattern CCCC is invalid
Pattern CVC is valid
	[[{'lit': 'ai', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ay', 'ln': 2, 'index': 1}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ei', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}, {'lit': 'ey', 'ln': 2, 'index': 1}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	MIN pattern length=3
	Pattern CCC is valid
	Pattern CVV is valid
	Pattern CV is invalid
	Pattern CVCC is valid
	Pattern CCCC is invalid
	Pattern CVC is valid
	Making the selection for pattern: CCC
	Selection for pattern: CCC completed
	Making a version for pattern: CCC
			___CCC : 0___
				ANALYSING: sig
				adding littera based on matching pattern
				ANALYSING: sigg
				adding littera based on matching pattern
				ANALYSING: sug
				adding littera based on matching pattern
				ANALYSING: sugg
				adding littera based on matching pattern
				ANALYSING: zigg
				adding littera based on matching pattern
				ANALYSING: zygg
				adding littera based on matching pattern
				ANALYSING: sæg
					resolving (1)
					> version: s/æ/g
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'æ', 'g']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sai
					resolving (3)
					> version: s/a/i
					TRYING: s
					> version: s/a/i
					TRYING: s
					> version: s/ai
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'a', 'i']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'a', 'i']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ai']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: say
					resolving (3)
					> version: s/a/y
					TRYING: s
					> version: s/a/y
					TRYING: s
					> version: s/ay
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'a', 'y']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'a', 'y']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ay']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: seg
					resolving (1)
					> version: s/e/g
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'e', 'g']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: segg
					resolving (2)
					> version: s/e/g/g
					TRYING: s
					> version: s/e/gg
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'e', 'g', 'g']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'e', 'gg']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sei
					resolving (3)
					> version: s/e/i
					TRYING: s
					> version: s/e/i
					TRYING: s
					> version: s/ei
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'e', 'i']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'e', 'i']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ei']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sey
					resolving (5)
					> version: s/e/y
					TRYING: s
					> version: s/e/y
					TRYING: s
					> version: s/ey
					TRYING: s
					> version: s/ey
					TRYING: s
					> version: s/ey
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'e', 'y']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'e', 'y']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ey']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ey']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ey']
				{'string': 's', 'rgx': '((s))$'}
			___CCC : 1___
				ANALYSING: sig
				adding littera based on matching pattern
				ANALYSING: sigg
				adding littera based on matching pattern
				ANALYSING: sug
				adding littera based on matching pattern
				ANALYSING: sugg
				adding littera based on matching pattern
				ANALYSING: zigg
				adding littera based on matching pattern
				ANALYSING: zygg
				adding littera based on matching pattern
				ANALYSING: sæg
					resolving (1)
					> version: s/æ/g
					TRYING: æ
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'æ', 'g']
				s/æ/g(CVC)
s/_/æ/g(CAVC)
				version split: ['s', 'æ', 'g']
				{'string': 's/æ', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'æ', 'g']
				version split: ['s', '_', 'æ', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				ANALYSING: sai
					resolving (3)
					> version: s/a/i
					TRYING: a
					> version: s/a/i
					TRYING: a
					> version: s/ai
					TRYING: ai
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'a', 'i']
				adding dashed alternative: ['s', '_', 'a', 'i']
				adding dashed alternative: ['s', '_', 'ai']
				s/a/i(CVC)
s/a/i(CVV)
s/ai(CV)
s/_/a/i(CAVA)
s/_/a/i(CAVA)
s/_/ai(CAV)
				version split: ['s', 'a', 'i']
				{'string': 's/a', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'a', 'i']
				version split: ['s', 'a', 'i']
				{'string': 's/a', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'a', 'i']
				version split: ['s', 'ai']
				{'string': 's/ai', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'ai']
				version split: ['s', '_', 'a', 'i']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'a', 'i']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'ai']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				ANALYSING: say
					resolving (3)
					> version: s/a/y
					TRYING: a
					> version: s/a/y
					TRYING: a
					> version: s/ay
					TRYING: ay
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'a', 'y']
				adding dashed alternative: ['s', '_', 'a', 'y']
				adding dashed alternative: ['s', '_', 'ay']
				s/a/y(CVC)
s/a/y(CVV)
s/ay(CV)
s/_/a/y(CAVA)
s/_/a/y(CAVA)
s/_/ay(CAV)
				version split: ['s', 'a', 'y']
				{'string': 's/a', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'a', 'y']
				version split: ['s', 'a', 'y']
				{'string': 's/a', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'a', 'y']
				version split: ['s', 'ay']
				{'string': 's/ay', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'ay']
				version split: ['s', '_', 'a', 'y']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'a', 'y']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'ay']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				ANALYSING: seg
					resolving (1)
					> version: s/e/g
					TRYING: e
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'e', 'g']
				s/e/g(CVC)
s/_/e/g(CAVC)
				version split: ['s', 'e', 'g']
				{'string': 's/e', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'e', 'g']
				version split: ['s', '_', 'e', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				ANALYSING: segg
					resolving (2)
					> version: s/e/g/g
					TRYING: e
					> version: s/e/gg
					TRYING: e
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'e', 'g', 'g']
				adding dashed alternative: ['s', '_', 'e', 'gg']
				s/e/g/g(CVCC)
s/e/gg(CVC)
s/_/e/g/g(CAVCC)
s/_/e/gg(CAVC)
				version split: ['s', 'e', 'g', 'g']
				{'string': 's/e', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'e', 'g', 'g']
				version split: ['s', 'e', 'gg']
				{'string': 's/e', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'e', 'gg']
				version split: ['s', '_', 'e', 'g', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'e', 'gg']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				ANALYSING: sei
					resolving (3)
					> version: s/e/i
					TRYING: e
					> version: s/e/i
					TRYING: e
					> version: s/ei
					TRYING: ei
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'e', 'i']
				adding dashed alternative: ['s', '_', 'e', 'i']
				adding dashed alternative: ['s', '_', 'ei']
				s/e/i(CVC)
s/e/i(CVV)
s/ei(CV)
s/_/e/i(CAVA)
s/_/e/i(CAVA)
s/_/ei(CAV)
				version split: ['s', 'e', 'i']
				{'string': 's/e', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'e', 'i']
				version split: ['s', 'e', 'i']
				{'string': 's/e', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'e', 'i']
				version split: ['s', 'ei']
				{'string': 's/ei', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'ei']
				version split: ['s', '_', 'e', 'i']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'e', 'i']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'ei']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				ANALYSING: sey
					resolving (5)
					> version: s/e/y
					TRYING: e
					> version: s/e/y
					TRYING: e
					> version: s/ey
					TRYING: ey
					> version: s/ey
					TRYING: ey
					> version: s/ey
					TRYING: ey
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'e', 'y']
				adding dashed alternative: ['s', '_', 'e', 'y']
				adding dashed alternative: ['s', '_', 'ey']
				adding dashed alternative: ['s', '_', 'ey']
				adding dashed alternative: ['s', '_', 'ey']
				s/e/y(CVC)
s/e/y(CVV)
s/ey(CV)
s/ey(CV)
s/ey(CV)
s/_/e/y(CAVA)
s/_/e/y(CAVA)
s/_/ey(CAV)
s/_/ey(CAV)
s/_/ey(CAV)
				version split: ['s', 'e', 'y']
				{'string': 's/e', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'e', 'y']
				version split: ['s', 'e', 'y']
				{'string': 's/e', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'e', 'y']
				version split: ['s', 'ey']
				{'string': 's/ey', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'ey']
				version split: ['s', 'ey']
				{'string': 's/ey', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'ey']
				version split: ['s', 'ey']
				{'string': 's/ey', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'ey']
				version split: ['s', '_', 'e', 'y']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'e', 'y']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'ey']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'ey']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'ey']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
			___CCC : 2___
				ANALYSING: sig
				adding littera based on matching pattern
				ANALYSING: sigg
				adding littera based on matching pattern
				ANALYSING: sug
				adding littera based on matching pattern
				ANALYSING: sugg
				adding littera based on matching pattern
				ANALYSING: zigg
				adding littera based on matching pattern
				ANALYSING: zygg
				adding littera based on matching pattern
				ANALYSING: sæg
					resolving (1)
					> version: s/_/æ/g
					TRYING: æ
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', '_', 'æ', 'g']
				s/_/æ/g(CAVC)
s/_/_/æ/g(CAAVC)
				version split: ['s', '_', 'æ', 'g']
				{'string': 's/_/æ/g', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'æ', 'g']
				version split: ['s', '_', '_', 'æ', 'g']
				{'string': 's/_/_/æ', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'æ', 'g']
				ANALYSING: sai
					resolving (3)
					> version: s/_/a/i
					TRYING: a
					> version: s/_/a/i
					TRYING: a
					> version: s/_/ai
					TRYING: ai
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', '_', 'a', 'i']
				adding dashed alternative: ['s', '_', '_', 'a', 'i']
				adding dashed alternative: ['s', '_', '_', 'ai']
				s/_/a/i(CAVA)
s/_/a/i(CAVA)
s/_/ai(CAV)
s/_/_/a/i(CAAVA)
s/_/_/a/i(CAAVA)
s/_/_/ai(CAAV)
				version split: ['s', '_', 'a', 'i']
				{'string': 's/_/a/i', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'a', 'i']
				version split: ['s', '_', 'a', 'i']
				{'string': 's/_/a/i', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'a', 'i']
				version split: ['s', '_', 'ai']
				{'string': 's/_/ai', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'ai']
				version split: ['s', '_', '_', 'a', 'i']
				{'string': 's/_/_/a', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'a', 'i']
				version split: ['s', '_', '_', 'a', 'i']
				{'string': 's/_/_/a', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'a', 'i']
				version split: ['s', '_', '_', 'ai']
				{'string': 's/_/_/ai', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'ai']
				ANALYSING: say
					resolving (3)
					> version: s/_/a/y
					TRYING: a
					> version: s/_/a/y
					TRYING: a
					> version: s/_/ay
					TRYING: ay
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', '_', 'a', 'y']
				adding dashed alternative: ['s', '_', '_', 'a', 'y']
				adding dashed alternative: ['s', '_', '_', 'ay']
				s/_/a/y(CAVA)
s/_/a/y(CAVA)
s/_/ay(CAV)
s/_/_/a/y(CAAVA)
s/_/_/a/y(CAAVA)
s/_/_/ay(CAAV)
				version split: ['s', '_', 'a', 'y']
				{'string': 's/_/a/y', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'a', 'y']
				version split: ['s', '_', 'a', 'y']
				{'string': 's/_/a/y', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'a', 'y']
				version split: ['s', '_', 'ay']
				{'string': 's/_/ay', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'ay']
				version split: ['s', '_', '_', 'a', 'y']
				{'string': 's/_/_/a', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'a', 'y']
				version split: ['s', '_', '_', 'a', 'y']
				{'string': 's/_/_/a', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'a', 'y']
				version split: ['s', '_', '_', 'ay']
				{'string': 's/_/_/ay', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'ay']
				ANALYSING: seg
					resolving (1)
					> version: s/_/e/g
					TRYING: e
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', '_', 'e', 'g']
				s/_/e/g(CAVC)
s/_/_/e/g(CAAVC)
				version split: ['s', '_', 'e', 'g']
				{'string': 's/_/e/g', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'e', 'g']
				version split: ['s', '_', '_', 'e', 'g']
				{'string': 's/_/_/e', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'e', 'g']
				ANALYSING: segg
					resolving (2)
					> version: s/_/e/g/g
					TRYING: e
					> version: s/_/e/gg
					TRYING: e
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', '_', 'e', 'g', 'g']
				adding dashed alternative: ['s', '_', '_', 'e', 'gg']
				s/_/e/g/g(CAVCC)
s/_/e/gg(CAVC)
s/_/_/e/g/g(CAAVCC)
s/_/_/e/gg(CAAVC)
				version split: ['s', '_', 'e', 'g', 'g']
				{'string': 's/_/e/g', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'e', 'g', 'g']
				version split: ['s', '_', 'e', 'gg']
				{'string': 's/_/e/gg', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'e', 'gg']
				version split: ['s', '_', '_', 'e', 'g', 'g']
				{'string': 's/_/_/e', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'e', 'g', 'g']
				version split: ['s', '_', '_', 'e', 'gg']
				{'string': 's/_/_/e', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'e', 'gg']
				ANALYSING: sei
					resolving (3)
					> version: s/_/e/i
					TRYING: e
					> version: s/_/e/i
					TRYING: e
					> version: s/_/ei
					TRYING: ei
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', '_', 'e', 'i']
				adding dashed alternative: ['s', '_', '_', 'e', 'i']
				adding dashed alternative: ['s', '_', '_', 'ei']
				s/_/e/i(CAVA)
s/_/e/i(CAVA)
s/_/ei(CAV)
s/_/_/e/i(CAAVA)
s/_/_/e/i(CAAVA)
s/_/_/ei(CAAV)
				version split: ['s', '_', 'e', 'i']
				{'string': 's/_/e/i', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'e', 'i']
				version split: ['s', '_', 'e', 'i']
				{'string': 's/_/e/i', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'e', 'i']
				version split: ['s', '_', 'ei']
				{'string': 's/_/ei', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'ei']
				version split: ['s', '_', '_', 'e', 'i']
				{'string': 's/_/_/e', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'e', 'i']
				version split: ['s', '_', '_', 'e', 'i']
				{'string': 's/_/_/e', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'e', 'i']
				version split: ['s', '_', '_', 'ei']
				{'string': 's/_/_/ei', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'ei']
				ANALYSING: sey
					resolving (5)
					> version: s/_/e/y
					TRYING: e
					> version: s/_/e/y
					TRYING: e
					> version: s/_/ey
					TRYING: ey
					> version: s/_/ey
					TRYING: ey
					> version: s/_/ey
					TRYING: ey
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', '_', 'e', 'y']
				adding dashed alternative: ['s', '_', '_', 'e', 'y']
				adding dashed alternative: ['s', '_', '_', 'ey']
				adding dashed alternative: ['s', '_', '_', 'ey']
				adding dashed alternative: ['s', '_', '_', 'ey']
				s/_/e/y(CAVA)
s/_/e/y(CAVA)
s/_/ey(CAV)
s/_/ey(CAV)
s/_/ey(CAV)
s/_/_/e/y(CAAVA)
s/_/_/e/y(CAAVA)
s/_/_/ey(CAAV)
s/_/_/ey(CAAV)
s/_/_/ey(CAAV)
				version split: ['s', '_', 'e', 'y']
				{'string': 's/_/e/y', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'e', 'y']
				version split: ['s', '_', 'e', 'y']
				{'string': 's/_/e/y', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'e', 'y']
				version split: ['s', '_', 'ey']
				{'string': 's/_/ey', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'ey']
				version split: ['s', '_', 'ey']
				{'string': 's/_/ey', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'ey']
				version split: ['s', '_', 'ey']
				{'string': 's/_/ey', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'ey']
				version split: ['s', '_', '_', 'e', 'y']
				{'string': 's/_/_/e', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'e', 'y']
				version split: ['s', '_', '_', 'e', 'y']
				{'string': 's/_/_/e', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'e', 'y']
				version split: ['s', '_', '_', 'ey']
				{'string': 's/_/_/ey', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'ey']
				version split: ['s', '_', '_', 'ey']
				{'string': 's/_/_/ey', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'ey']
				version split: ['s', '_', '_', 'ey']
				{'string': 's/_/_/ey', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'ey']
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		SPLIT: ['s', 'i', 'g']
		SPLIT: ['s', 'i', 'gg']
		SPLIT: ['s', 'u', 'g']
		SPLIT: ['s', 'u', 'gg']
		SPLIT: ['z', 'i', 'gg']
		SPLIT: ['z', 'y', 'gg']
		SPLIT: ["['s']", "['_']", "['_']"]
		SPLIT: ["['s']", "['_']", "['_']"]
		SPLIT: ["['s']", "['_']", "['_']"]
		SPLIT: ["['s']", "['_']", "['_']"]
		SPLIT: ["['s']", "['_']", "['_']"]
		SPLIT: ["['s']", "['_']", "['_']"]
		SPLIT: ["['s']", "['_']", "['_']"]
		version for pattern CCC is INVALID
		[]
		7
		OVERVIEW: version for pattern CCC

faulty splits: 7
['s'][''][''] <-! sæg
['s'][''][''] <-! sai
['s'][''][''] <-! say
['s'][''][''] <-! seg
['s'][''][''] <-! segg
['s'][''][''] <-! sei
['s'][''][''] <-! sey
s | i | g
s | i | gg
s | u | g
s | u | gg
z | i | gg
z | y | gg
['s'] | ['_'] | ['_']
['s'] | ['_'] | ['_']
['s'] | ['_'] | ['_']
['s'] | ['_'] | ['_']
['s'] | ['_'] | ['_']
['s'] | ['_'] | ['_']
['s'] | ['_'] | ['_']
	[[{'lit': 'ai', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ay', 'ln': 2, 'index': 1}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ei', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}, {'lit': 'ey', 'ln': 2, 'index': 1}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	MIN pattern length=3
	Pattern CCC is valid
	Pattern CVV is valid
	Pattern CV is invalid
	Pattern CVCC is valid
	Pattern CCCC is invalid
	Pattern CVC is valid
	Making the selection for pattern: CVV
	Selection for pattern: CVV completed
	Making a version for pattern: CVV
			___CVV : 0___
				ANALYSING: sai
				adding littera based on matching pattern
				ANALYSING: say
				adding littera based on matching pattern
				ANALYSING: sei
				adding littera based on matching pattern
				ANALYSING: sey
				adding littera based on matching pattern
				ANALYSING: sæg
					resolving (1)
					> version: s/æ/g
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'æ', 'g']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: seg
					resolving (1)
					> version: s/e/g
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'e', 'g']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: segg
					resolving (2)
					> version: s/e/g/g
					TRYING: s
					> version: s/e/gg
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'e', 'g', 'g']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'e', 'gg']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sig
					resolving (2)
					> version: s/i/g
					TRYING: s
					> version: s/i/g
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'i', 'g']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'i', 'g']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sigg
					resolving (4)
					> version: s/i/g/g
					TRYING: s
					> version: s/i/g/g
					TRYING: s
					> version: s/i/gg
					TRYING: s
					> version: s/i/gg
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'i', 'g', 'g']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'i', 'g', 'g']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'i', 'gg']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'i', 'gg']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sug
					resolving (2)
					> version: s/u/g
					TRYING: s
					> version: s/u/g
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'u', 'g']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'u', 'g']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sugg
					resolving (4)
					> version: s/u/g/g
					TRYING: s
					> version: s/u/g/g
					TRYING: s
					> version: s/u/gg
					TRYING: s
					> version: s/u/gg
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'u', 'g', 'g']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'u', 'g', 'g']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'u', 'gg']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'u', 'gg']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: zigg
					resolving (4)
					> version: z/i/g/g
					TRYING: z
					> version: z/i/g/g
					TRYING: z
					> version: z/i/gg
					TRYING: z
					> version: z/i/gg
					TRYING: z
					RESULT:  ['z']
				version split: ['z', 'i', 'g', 'g']
				{'string': 'z', 'rgx': '((z))$'}
				version split: ['z', 'i', 'g', 'g']
				{'string': 'z', 'rgx': '((z))$'}
				version split: ['z', 'i', 'gg']
				{'string': 'z', 'rgx': '((z))$'}
				version split: ['z', 'i', 'gg']
				{'string': 'z', 'rgx': '((z))$'}
				ANALYSING: zygg
					resolving (4)
					> version: z/y/g/g
					TRYING: z
					> version: z/y/g/g
					TRYING: z
					> version: z/y/gg
					TRYING: z
					> version: z/y/gg
					TRYING: z
					RESULT:  ['z']
				version split: ['z', 'y', 'g', 'g']
				{'string': 'z', 'rgx': '((z))$'}
				version split: ['z', 'y', 'g', 'g']
				{'string': 'z', 'rgx': '((z))$'}
				version split: ['z', 'y', 'gg']
				{'string': 'z', 'rgx': '((z))$'}
				version split: ['z', 'y', 'gg']
				{'string': 'z', 'rgx': '((z))$'}
			___CVV : 1___
				ANALYSING: sai
				adding littera based on matching pattern
				ANALYSING: say
				adding littera based on matching pattern
				ANALYSING: sei
				adding littera based on matching pattern
				ANALYSING: sey
				adding littera based on matching pattern
				ANALYSING: sæg
					resolving (1)
					> version: s/æ/g
					TRYING: æ
					RESULT:  ['æ']
				version split: ['s', 'æ', 'g']
				{'string': 's/æ', 'rgx': '((s))/((æ))$'}
				ANALYSING: seg
					resolving (1)
					> version: s/e/g
					TRYING: e
					RESULT:  ['e']
				version split: ['s', 'e', 'g']
				{'string': 's/e', 'rgx': '((s))/((e))$'}
				ANALYSING: segg
					resolving (2)
					> version: s/e/g/g
					TRYING: e
					> version: s/e/gg
					TRYING: e
					RESULT:  ['e']
				version split: ['s', 'e', 'g', 'g']
				{'string': 's/e', 'rgx': '((s))/((e))$'}
				version split: ['s', 'e', 'gg']
				{'string': 's/e', 'rgx': '((s))/((e))$'}
				ANALYSING: sig
					resolving (2)
					> version: s/i/g
					TRYING: i
					adding blocked set: V = V >> e, æ, i, a
					> version: s/i/g
					TRYING: i
					adding blocked set: V = V >> e, æ, i, a
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'i', 'g']
				adding dashed alternative: ['s', '_', 'i', 'g']
				s/i/g(CCC)
s/i/g(CVC)
s/_/i/g(CAAC)
s/_/i/g(CAAC)
				version split: ['s', 'i', 'g']
				{'string': 's/i', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'i', 'g']
				version split: ['s', 'i', 'g']
				{'string': 's/i', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'i', 'g']
				version split: ['s', '_', 'i', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'i', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				ANALYSING: sigg
					resolving (4)
					> version: s/i/g/g
					TRYING: i
					adding blocked set: V = V >> æ, e, _, i, a
					> version: s/i/g/g
					TRYING: i
					adding blocked set: V = V >> æ, e, _, i, a
					> version: s/i/gg
					TRYING: i
					adding blocked set: V = V >> æ, e, _, i, a
					> version: s/i/gg
					TRYING: i
					adding blocked set: V = V >> æ, e, _, i, a
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'i', 'g', 'g']
				adding dashed alternative: ['s', '_', 'i', 'g', 'g']
				adding dashed alternative: ['s', '_', 'i', 'gg']
				adding dashed alternative: ['s', '_', 'i', 'gg']
				s/i/g/g(CCCC)
s/i/g/g(CVCC)
s/i/gg(CCC)
s/i/gg(CVC)
s/_/i/g/g(CAACC)
s/_/i/g/g(CAACC)
s/_/i/gg(CAAC)
s/_/i/gg(CAAC)
				version split: ['s', 'i', 'g', 'g']
				{'string': 's/i', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'i', 'g', 'g']
				version split: ['s', 'i', 'g', 'g']
				{'string': 's/i', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'i', 'g', 'g']
				version split: ['s', 'i', 'gg']
				{'string': 's/i', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'i', 'gg']
				version split: ['s', 'i', 'gg']
				{'string': 's/i', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'i', 'gg']
				version split: ['s', '_', 'i', 'g', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'i', 'g', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'i', 'gg']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'i', 'gg']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				ANALYSING: sug
					resolving (2)
					> version: s/u/g
					TRYING: u
					adding blocked set: V = V >> æ, u, e, _, a
					> version: s/u/g
					TRYING: u
					adding blocked set: V = V >> æ, u, e, _, a
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'u', 'g']
				adding dashed alternative: ['s', '_', 'u', 'g']
				s/u/g(CCC)
s/u/g(CVC)
s/_/u/g(CAAC)
s/_/u/g(CAAC)
				version split: ['s', 'u', 'g']
				{'string': 's/u', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'u', 'g']
				version split: ['s', 'u', 'g']
				{'string': 's/u', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'u', 'g']
				version split: ['s', '_', 'u', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'u', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				ANALYSING: sugg
					resolving (4)
					> version: s/u/g/g
					TRYING: u
					adding blocked set: V = V >> æ, u, e, _, a
					> version: s/u/g/g
					TRYING: u
					adding blocked set: V = V >> æ, u, e, _, a
					> version: s/u/gg
					TRYING: u
					adding blocked set: V = V >> æ, u, e, _, a
					> version: s/u/gg
					TRYING: u
					adding blocked set: V = V >> æ, u, e, _, a
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'u', 'g', 'g']
				adding dashed alternative: ['s', '_', 'u', 'g', 'g']
				adding dashed alternative: ['s', '_', 'u', 'gg']
				adding dashed alternative: ['s', '_', 'u', 'gg']
				s/u/g/g(CCCC)
s/u/g/g(CVCC)
s/u/gg(CCC)
s/u/gg(CVC)
s/_/u/g/g(CAACC)
s/_/u/g/g(CAACC)
s/_/u/gg(CAAC)
s/_/u/gg(CAAC)
				version split: ['s', 'u', 'g', 'g']
				{'string': 's/u', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'u', 'g', 'g']
				version split: ['s', 'u', 'g', 'g']
				{'string': 's/u', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'u', 'g', 'g']
				version split: ['s', 'u', 'gg']
				{'string': 's/u', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'u', 'gg']
				version split: ['s', 'u', 'gg']
				{'string': 's/u', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'u', 'gg']
				version split: ['s', '_', 'u', 'g', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'u', 'g', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'u', 'gg']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				version split: ['s', '_', 'u', 'gg']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				ANALYSING: zigg
					resolving (4)
					> version: z/i/g/g
					TRYING: i
					adding blocked set: V = V >> æ, e, _, i, a
					> version: z/i/g/g
					TRYING: i
					adding blocked set: V = V >> æ, e, _, i, a
					> version: z/i/gg
					TRYING: i
					adding blocked set: V = V >> æ, e, _, i, a
					> version: z/i/gg
					TRYING: i
					adding blocked set: V = V >> æ, e, _, i, a
					RESULT:  ['_']
				adding dashed alternative: ['z', '_', 'i', 'g', 'g']
				adding dashed alternative: ['z', '_', 'i', 'g', 'g']
				adding dashed alternative: ['z', '_', 'i', 'gg']
				adding dashed alternative: ['z', '_', 'i', 'gg']
				z/i/g/g(CCCC)
z/i/g/g(CVCC)
z/i/gg(CCC)
z/i/gg(CVC)
z/_/i/g/g(CAACC)
z/_/i/g/g(CAACC)
z/_/i/gg(CAAC)
z/_/i/gg(CAAC)
				version split: ['z', 'i', 'g', 'g']
				{'string': 'z/i', 'rgx': '((z))/((_))$'}
				_____REMOVING________['z', 'i', 'g', 'g']
				version split: ['z', 'i', 'g', 'g']
				{'string': 'z/i', 'rgx': '((z))/((_))$'}
				_____REMOVING________['z', 'i', 'g', 'g']
				version split: ['z', 'i', 'gg']
				{'string': 'z/i', 'rgx': '((z))/((_))$'}
				_____REMOVING________['z', 'i', 'gg']
				version split: ['z', 'i', 'gg']
				{'string': 'z/i', 'rgx': '((z))/((_))$'}
				_____REMOVING________['z', 'i', 'gg']
				version split: ['z', '_', 'i', 'g', 'g']
				{'string': 'z/_', 'rgx': '((z))/((_))$'}
				version split: ['z', '_', 'i', 'g', 'g']
				{'string': 'z/_', 'rgx': '((z))/((_))$'}
				version split: ['z', '_', 'i', 'gg']
				{'string': 'z/_', 'rgx': '((z))/((_))$'}
				version split: ['z', '_', 'i', 'gg']
				{'string': 'z/_', 'rgx': '((z))/((_))$'}
				ANALYSING: zygg
					resolving (4)
					> version: z/y/g/g
					TRYING: y
					adding blocked set: V = V >> y, æ, e, _, a
					> version: z/y/g/g
					TRYING: y
					adding blocked set: V = V >> y, æ, e, _, a
					> version: z/y/gg
					TRYING: y
					adding blocked set: V = V >> y, æ, e, _, a
					> version: z/y/gg
					TRYING: y
					adding blocked set: V = V >> y, æ, e, _, a
					RESULT:  ['_']
				adding dashed alternative: ['z', '_', 'y', 'g', 'g']
				adding dashed alternative: ['z', '_', 'y', 'g', 'g']
				adding dashed alternative: ['z', '_', 'y', 'gg']
				adding dashed alternative: ['z', '_', 'y', 'gg']
				z/y/g/g(CCCC)
z/y/g/g(CVCC)
z/y/gg(CCC)
z/y/gg(CVC)
z/_/y/g/g(CAACC)
z/_/y/g/g(CAACC)
z/_/y/gg(CAAC)
z/_/y/gg(CAAC)
				version split: ['z', 'y', 'g', 'g']
				{'string': 'z/y', 'rgx': '((z))/((_))$'}
				_____REMOVING________['z', 'y', 'g', 'g']
				version split: ['z', 'y', 'g', 'g']
				{'string': 'z/y', 'rgx': '((z))/((_))$'}
				_____REMOVING________['z', 'y', 'g', 'g']
				version split: ['z', 'y', 'gg']
				{'string': 'z/y', 'rgx': '((z))/((_))$'}
				_____REMOVING________['z', 'y', 'gg']
				version split: ['z', 'y', 'gg']
				{'string': 'z/y', 'rgx': '((z))/((_))$'}
				_____REMOVING________['z', 'y', 'gg']
				version split: ['z', '_', 'y', 'g', 'g']
				{'string': 'z/_', 'rgx': '((z))/((_))$'}
				version split: ['z', '_', 'y', 'g', 'g']
				{'string': 'z/_', 'rgx': '((z))/((_))$'}
				version split: ['z', '_', 'y', 'gg']
				{'string': 'z/_', 'rgx': '((z))/((_))$'}
				version split: ['z', '_', 'y', 'gg']
				{'string': 'z/_', 'rgx': '((z))/((_))$'}
			___CVV : 2___
				ANALYSING: sai
				adding littera based on matching pattern
				ANALYSING: say
				adding littera based on matching pattern
				ANALYSING: sei
				adding littera based on matching pattern
				ANALYSING: sey
				adding littera based on matching pattern
				ANALYSING: sæg
					resolving (1)
					> version: s/æ/g
					TRYING: g
					RESULT:  ['_']
				adding dashed alternative: ['s', 'æ', '_', 'g']
				s/æ/g(CVC)
s/æ/_/g(CVAC)
				version split: ['s', 'æ', 'g']
				{'string': 's/æ/g', 'rgx': '((s))/((æ))/((_))$'}
				_____REMOVING________['s', 'æ', 'g']
				version split: ['s', 'æ', '_', 'g']
				{'string': 's/æ/_/g', 'rgx': '((s))/((æ))/((_))$'}
				_____REMOVING________['s', 'æ', '_', 'g']
				ANALYSING: seg
					resolving (1)
					> version: s/e/g
					TRYING: g
					RESULT:  ['_']
				adding dashed alternative: ['s', 'e', '_', 'g']
				s/e/g(CVC)
s/e/_/g(CVAC)
				version split: ['s', 'e', 'g']
				{'string': 's/e/g', 'rgx': '((s))/((e))/((_))$'}
				_____REMOVING________['s', 'e', 'g']
				version split: ['s', 'e', '_', 'g']
				{'string': 's/e/_/g', 'rgx': '((s))/((e))/((_))$'}
				_____REMOVING________['s', 'e', '_', 'g']
				ANALYSING: segg
					resolving (2)
					> version: s/e/g/g
					TRYING: g
					> version: s/e/gg
					TRYING: gg
					RESULT:  ['_']
				adding dashed alternative: ['s', 'e', '_', 'g', 'g']
				adding dashed alternative: ['s', 'e', '_', 'gg']
				s/e/g/g(CVCC)
s/e/gg(CVC)
s/e/_/g/g(CVACC)
s/e/_/gg(CVAC)
				version split: ['s', 'e', 'g', 'g']
				{'string': 's/e/g/g', 'rgx': '((s))/((e))/((_))$'}
				_____REMOVING________['s', 'e', 'g', 'g']
				version split: ['s', 'e', 'gg']
				{'string': 's/e/gg', 'rgx': '((s))/((e))/((_))$'}
				_____REMOVING________['s', 'e', 'gg']
				version split: ['s', 'e', '_', 'g', 'g']
				{'string': 's/e/_/g', 'rgx': '((s))/((e))/((_))$'}
				_____REMOVING________['s', 'e', '_', 'g', 'g']
				version split: ['s', 'e', '_', 'gg']
				{'string': 's/e/_/gg', 'rgx': '((s))/((e))/((_))$'}
				_____REMOVING________['s', 'e', '_', 'gg']
				ANALYSING: sig
					resolving (2)
					> version: s/_/i/g
					TRYING: i
					> version: s/_/i/g
					TRYING: i
					RESULT:  ['i']
				version split: ['s', '_', 'i', 'g']
				{'string': 's/_/i/g', 'rgx': '((s))/((_))/((i))$'}
				_____REMOVING________['s', '_', 'i', 'g']
				version split: ['s', '_', 'i', 'g']
				{'string': 's/_/i/g', 'rgx': '((s))/((_))/((i))$'}
				_____REMOVING________['s', '_', 'i', 'g']
				ANALYSING: sigg
					resolving (4)
					> version: s/_/i/g/g
					TRYING: i
					> version: s/_/i/g/g
					TRYING: i
					> version: s/_/i/gg
					TRYING: i
					> version: s/_/i/gg
					TRYING: i
					RESULT:  ['i']
				version split: ['s', '_', 'i', 'g', 'g']
				{'string': 's/_/i/g', 'rgx': '((s))/((_))/((i))$'}
				_____REMOVING________['s', '_', 'i', 'g', 'g']
				version split: ['s', '_', 'i', 'g', 'g']
				{'string': 's/_/i/g', 'rgx': '((s))/((_))/((i))$'}
				_____REMOVING________['s', '_', 'i', 'g', 'g']
				version split: ['s', '_', 'i', 'gg']
				{'string': 's/_/i/gg', 'rgx': '((s))/((_))/((i))$'}
				_____REMOVING________['s', '_', 'i', 'gg']
				version split: ['s', '_', 'i', 'gg']
				{'string': 's/_/i/gg', 'rgx': '((s))/((_))/((i))$'}
				_____REMOVING________['s', '_', 'i', 'gg']
				ANALYSING: sug
					resolving (2)
					> version: s/_/u/g
					TRYING: u
					> version: s/_/u/g
					TRYING: u
					RESULT:  ['u']
				version split: ['s', '_', 'u', 'g']
				{'string': 's/_/u/g', 'rgx': '((s))/((_))/((u))$'}
				_____REMOVING________['s', '_', 'u', 'g']
				version split: ['s', '_', 'u', 'g']
				{'string': 's/_/u/g', 'rgx': '((s))/((_))/((u))$'}
				_____REMOVING________['s', '_', 'u', 'g']
				ANALYSING: sugg
					resolving (4)
					> version: s/_/u/g/g
					TRYING: u
					> version: s/_/u/g/g
					TRYING: u
					> version: s/_/u/gg
					TRYING: u
					> version: s/_/u/gg
					TRYING: u
					RESULT:  ['u']
				version split: ['s', '_', 'u', 'g', 'g']
				{'string': 's/_/u/g', 'rgx': '((s))/((_))/((u))$'}
				_____REMOVING________['s', '_', 'u', 'g', 'g']
				version split: ['s', '_', 'u', 'g', 'g']
				{'string': 's/_/u/g', 'rgx': '((s))/((_))/((u))$'}
				_____REMOVING________['s', '_', 'u', 'g', 'g']
				version split: ['s', '_', 'u', 'gg']
				{'string': 's/_/u/gg', 'rgx': '((s))/((_))/((u))$'}
				_____REMOVING________['s', '_', 'u', 'gg']
				version split: ['s', '_', 'u', 'gg']
				{'string': 's/_/u/gg', 'rgx': '((s))/((_))/((u))$'}
				_____REMOVING________['s', '_', 'u', 'gg']
				ANALYSING: zigg
					resolving (4)
					> version: z/_/i/g/g
					TRYING: i
					> version: z/_/i/g/g
					TRYING: i
					> version: z/_/i/gg
					TRYING: i
					> version: z/_/i/gg
					TRYING: i
					RESULT:  ['i']
				version split: ['z', '_', 'i', 'g', 'g']
				{'string': 'z/_/i/g', 'rgx': '((z))/((_))/((i))$'}
				_____REMOVING________['z', '_', 'i', 'g', 'g']
				version split: ['z', '_', 'i', 'g', 'g']
				{'string': 'z/_/i/g', 'rgx': '((z))/((_))/((i))$'}
				_____REMOVING________['z', '_', 'i', 'g', 'g']
				version split: ['z', '_', 'i', 'gg']
				{'string': 'z/_/i/gg', 'rgx': '((z))/((_))/((i))$'}
				_____REMOVING________['z', '_', 'i', 'gg']
				version split: ['z', '_', 'i', 'gg']
				{'string': 'z/_/i/gg', 'rgx': '((z))/((_))/((i))$'}
				_____REMOVING________['z', '_', 'i', 'gg']
				ANALYSING: zygg
					resolving (4)
					> version: z/_/y/g/g
					TRYING: y
					> version: z/_/y/g/g
					TRYING: y
					> version: z/_/y/gg
					TRYING: y
					> version: z/_/y/gg
					TRYING: y
					RESULT:  ['y']
				version split: ['z', '_', 'y', 'g', 'g']
				{'string': 'z/_/y/g', 'rgx': '((z))/((_))/((y))$'}
				_____REMOVING________['z', '_', 'y', 'g', 'g']
				version split: ['z', '_', 'y', 'g', 'g']
				{'string': 'z/_/y/g', 'rgx': '((z))/((_))/((y))$'}
				_____REMOVING________['z', '_', 'y', 'g', 'g']
				version split: ['z', '_', 'y', 'gg']
				{'string': 'z/_/y/gg', 'rgx': '((z))/((_))/((y))$'}
				_____REMOVING________['z', '_', 'y', 'gg']
				version split: ['z', '_', 'y', 'gg']
				{'string': 'z/_/y/gg', 'rgx': '((z))/((_))/((y))$'}
				_____REMOVING________['z', '_', 'y', 'gg']
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		SPLIT: ['s', 'a', 'i']
		SPLIT: ['s', 'a', 'y']
		SPLIT: ['s', 'e', 'i']
		SPLIT: ['s', 'e', 'y']
		SPLIT: ["['s']", "['æ']", "['_']"]
		SPLIT: ["['s']", "['e']", "['_']"]
		SPLIT: ["['s']", "['e']", "['_']"]
		SPLIT: ["['s']", "['_']", "['i']"]
		SPLIT: ["['s']", "['_']", "['i']"]
		SPLIT: ["['s']", "['_']", "['u']"]
		SPLIT: ["['s']", "['_']", "['u']"]
		SPLIT: ["['z']", "['_']", "['i']"]
		SPLIT: ["['z']", "['_']", "['y']"]
		version for pattern CVV is INVALID
		[]
		9
		OVERVIEW: version for pattern CVV

faulty splits: 9
['s']['æ'][''] <-! sæg
['s']['e'][''] <-! seg
['s']['e'][''] <-! segg
['s']['']['i'] <-! sig
['s']['']['i'] <-! sigg
['s']['']['u'] <-! sug
['s']['']['u'] <-! sugg
['z']['']['i'] <-! zigg
['z']['']['y'] <-! zygg
s | a | i
s | a | y
s | e | i
s | e | y
['s'] | ['æ'] | ['_']
['s'] | ['e'] | ['_']
['s'] | ['e'] | ['_']
['s'] | ['_'] | ['i']
['s'] | ['_'] | ['i']
['s'] | ['_'] | ['u']
['s'] | ['_'] | ['u']
['z'] | ['_'] | ['i']
['z'] | ['_'] | ['y']
1 : {'æ', 'e', '_', 'i', 'a'},{'æ', 'u', 'e', '_', 'a'},{'æ', 'u', 'e', '_', 'a'},{'æ', 'e', '_', 'i', 'a'},{'æ', 'e', '_', 'i', 'a'},{'y', 'æ', 'e', '_', 'a'},{'æ', 'u', 'e', '_', 'a'},{'æ', 'e', '_', 'i', 'a'},{'æ', 'e', '_', 'i', 'a'},{'æ', 'u', 'e', '_', 'a'},{'æ', 'e', '_', 'i', 'a'},{'æ', 'e', '_', 'i', 'a'},{'e', 'æ', 'i', 'a'},{'æ', 'u', 'e', '_', 'a'},{'y', 'æ', 'e', '_', 'a'},{'e', 'æ', 'i', 'a'},{'æ', 'u', 'e', '_', 'a'},{'y', 'æ', 'e', '_', 'a'},{'æ', 'e', '_', 'i', 'a'},{'y', 'æ', 'e', '_', 'a'}
	[[{'lit': 'ai', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ay', 'ln': 2, 'index': 1}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ei', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}, {'lit': 'ey', 'ln': 2, 'index': 1}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	MIN pattern length=3
	Pattern CCC is valid
	Pattern CVV is valid
	Pattern CV is invalid
	Pattern CVCC is valid
	Pattern CCCC is invalid
	Pattern CVC is valid
	Making the selection for pattern: CVCC
	Selection for pattern: CVCC completed
	Making a version for pattern: CVCC
			___CVCC : 0___
				ANALYSING: segg
				adding littera based on matching pattern
				ANALYSING: sigg
				adding littera based on matching pattern
				ANALYSING: sugg
				adding littera based on matching pattern
				ANALYSING: zigg
				adding littera based on matching pattern
				ANALYSING: zygg
				adding littera based on matching pattern
				ANALYSING: sæg
					resolving (1)
					> version: s/æ/g
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'æ', 'g']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sai
					resolving (3)
					> version: s/a/i
					TRYING: s
					> version: s/a/i
					TRYING: s
					> version: s/ai
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'a', 'i']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'a', 'i']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ai']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: say
					resolving (3)
					> version: s/a/y
					TRYING: s
					> version: s/a/y
					TRYING: s
					> version: s/ay
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'a', 'y']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'a', 'y']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ay']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: seg
					resolving (1)
					> version: s/e/g
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'e', 'g']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sei
					resolving (3)
					> version: s/e/i
					TRYING: s
					> version: s/e/i
					TRYING: s
					> version: s/ei
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'e', 'i']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'e', 'i']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ei']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sey
					resolving (5)
					> version: s/e/y
					TRYING: s
					> version: s/e/y
					TRYING: s
					> version: s/ey
					TRYING: s
					> version: s/ey
					TRYING: s
					> version: s/ey
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'e', 'y']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'e', 'y']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ey']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ey']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'ey']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sig
					resolving (2)
					> version: s/i/g
					TRYING: s
					> version: s/i/g
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'i', 'g']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'i', 'g']
				{'string': 's', 'rgx': '((s))$'}
				ANALYSING: sug
					resolving (2)
					> version: s/u/g
					TRYING: s
					> version: s/u/g
					TRYING: s
					RESULT:  ['s']
				version split: ['s', 'u', 'g']
				{'string': 's', 'rgx': '((s))$'}
				version split: ['s', 'u', 'g']
				{'string': 's', 'rgx': '((s))$'}
			___CVCC : 1___
				ANALYSING: segg
				adding littera based on matching pattern
				ANALYSING: sigg
				adding littera based on matching pattern
				ANALYSING: sugg
				adding littera based on matching pattern
				ANALYSING: zigg
				adding littera based on matching pattern
				ANALYSING: zygg
				adding littera based on matching pattern
				ANALYSING: sæg
					resolving (1)
					> version: s/æ/g
					TRYING: æ
					adding blocked set: V = V >> y, æ, u, e, i
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', 'æ', 'g']
				s/æ/g(CVC)
s/_/æ/g(CAVC)
				version split: ['s', 'æ', 'g']
				{'string': 's/æ', 'rgx': '((s))/((_))$'}
				_____REMOVING________['s', 'æ', 'g']
				version split: ['s', '_', 'æ', 'g']
				{'string': 's/_', 'rgx': '((s))/((_))$'}
				ANALYSING: sai
					resolving (3)
					> version: s/a/i
					TRYING: a
					> version: s/a/i
					TRYING: a
					> version: s/ai
					TRYING: ai
					>>> MULTIPLE RESOLVE OPTIONS: {'ai', 'a'}
					RESULT:  ['ai', 'a']
				version split: ['s', 'a', 'i']
				{'string': 's/a', 'rgx': '((s))/((ai)|(a))$'}
				version split: ['s', 'a', 'i']
				{'string': 's/a', 'rgx': '((s))/((ai)|(a))$'}
				version split: ['s', 'ai']
				{'string': 's/ai', 'rgx': '((s))/((ai)|(a))$'}
				ANALYSING: say
					resolving (3)
					> version: s/a/y
					TRYING: a
					> version: s/a/y
					TRYING: a
					> version: s/ay
					TRYING: ay
					adding blocked set: V = V >> ay, y, u, e, _, ai, i, a
					RESULT:  ['a']
				version split: ['s', 'a', 'y']
				{'string': 's/a', 'rgx': '((s))/((a))$'}
				version split: ['s', 'a', 'y']
				{'string': 's/a', 'rgx': '((s))/((a))$'}
				version split: ['s', 'ay']
				{'string': 's/ay', 'rgx': '((s))/((a))$'}
				_____REMOVING________['s', 'ay']
				ANALYSING: seg
					resolving (1)
					> version: s/e/g
					TRYING: e
					RESULT:  ['e']
				version split: ['s', 'e', 'g']
				{'string': 's/e', 'rgx': '((s))/((e))$'}
				ANALYSING: sei
					resolving (3)
					> version: s/e/i
					TRYING: e
					> version: s/e/i
					TRYING: e
					> version: s/ei
					TRYING: ei
					adding blocked set: V = V >> y, u, e, _, ai, i, a, ei
					RESULT:  ['e']
				version split: ['s', 'e', 'i']
				{'string': 's/e', 'rgx': '((s))/((e))$'}
				version split: ['s', 'e', 'i']
				{'string': 's/e', 'rgx': '((s))/((e))$'}
				version split: ['s', 'ei']
				{'string': 's/ei', 'rgx': '((s))/((e))$'}
				_____REMOVING________['s', 'ei']
				ANALYSING: sey
					resolving (5)
					> version: s/e/y
					TRYING: e
					> version: s/e/y
					TRYING: e
					> version: s/ey
					TRYING: ey
					adding blocked set: V = V >> y, u, e, _, ai, i, ey, a
					> version: s/ey
					TRYING: ey
					adding blocked set: V = V >> y, u, e, _, ai, i, ey, a
					> version: s/ey
					TRYING: ey
					adding blocked set: V = V >> y, u, e, _, ai, i, ey, a
					RESULT:  ['e']
				version split: ['s', 'e', 'y']
				{'string': 's/e', 'rgx': '((s))/((e))$'}
				version split: ['s', 'e', 'y']
				{'string': 's/e', 'rgx': '((s))/((e))$'}
				version split: ['s', 'ey']
				{'string': 's/ey', 'rgx': '((s))/((e))$'}
				_____REMOVING________['s', 'ey']
				version split: ['s', 'ey']
				{'string': 's/ey', 'rgx': '((s))/((e))$'}
				_____REMOVING________['s', 'ey']
				version split: ['s', 'ey']
				{'string': 's/ey', 'rgx': '((s))/((e))$'}
				_____REMOVING________['s', 'ey']
				ANALYSING: sig
					resolving (2)
					> version: s/i/g
					TRYING: i
					> version: s/i/g
					TRYING: i
					RESULT:  ['i']
				version split: ['s', 'i', 'g']
				{'string': 's/i', 'rgx': '((s))/((i))$'}
				version split: ['s', 'i', 'g']
				{'string': 's/i', 'rgx': '((s))/((i))$'}
				ANALYSING: sug
					resolving (2)
					> version: s/u/g
					TRYING: u
					> version: s/u/g
					TRYING: u
					RESULT:  ['u']
				version split: ['s', 'u', 'g']
				{'string': 's/u', 'rgx': '((s))/((u))$'}
				version split: ['s', 'u', 'g']
				{'string': 's/u', 'rgx': '((s))/((u))$'}
			___CVCC : 2___
				ANALYSING: segg
				adding littera based on matching pattern
				ANALYSING: sigg
				adding littera based on matching pattern
				ANALYSING: sugg
				adding littera based on matching pattern
				ANALYSING: zigg
				adding littera based on matching pattern
				ANALYSING: zygg
				adding littera based on matching pattern
				ANALYSING: sæg
					resolving (1)
					> version: s/_/æ/g
					TRYING: æ
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', '_', 'æ', 'g']
				s/_/æ/g(CAVC)
s/_/_/æ/g(CAAVC)
				version split: ['s', '_', 'æ', 'g']
				{'string': 's/_/æ', 'rgx': '((s))/((_))/((_))$'}
				_____REMOVING________['s', '_', 'æ', 'g']
				version split: ['s', '_', '_', 'æ', 'g']
				{'string': 's/_/_', 'rgx': '((s))/((_))/((_))$'}
				ANALYSING: sai
					resolving (3)
					> version: s/a/i
					TRYING: i
					adding blocked set: C = C >> _, i, g
					> version: s/a/i
					TRYING: i
					adding blocked set: C = C >> _, i, g
					> version: s/ai
					RESULT:  ['_']
				adding dashed alternative: ['s', 'a', '_', 'i']
				adding dashed alternative: ['s', 'a', '_', 'i']
				adding dashed alternative: ['s', 'ai', '_']
				s/a/i(CVC)
s/a/i(CVV)
s/ai(CV)
s/a/_/i(CVAA)
s/a/_/i(CVAA)
s/ai/_(CVA)
				version split: ['s', 'a', 'i']
				{'string': 's/a/i', 'rgx': '((s))/((ai)|(a))/((_))$'}
				_____REMOVING________['s', 'a', 'i']
				version split: ['s', 'a', 'i']
				{'string': 's/a/i', 'rgx': '((s))/((ai)|(a))/((_))$'}
				_____REMOVING________['s', 'a', 'i']
				version split: ['s', 'ai']
				{'string': 's/ai', 'rgx': '((s))/((ai)|(a))/((_))$'}
				_____REMOVING________['s', 'ai']
				version split: ['s', 'a', '_', 'i']
				{'string': 's/a/_', 'rgx': '((s))/((ai)|(a))/((_))$'}
				version split: ['s', 'a', '_', 'i']
				{'string': 's/a/_', 'rgx': '((s))/((ai)|(a))/((_))$'}
				version split: ['s', 'ai', '_']
				{'string': 's/ai/_', 'rgx': '((s))/((ai)|(a))/((_))$'}
				ANALYSING: say
					resolving (2)
					> version: s/a/y
					TRYING: y
					> version: s/a/y
					TRYING: y
					RESULT:  ['y']
				version split: ['s', 'a', 'y']
				{'string': 's/a/y', 'rgx': '((s))/((a))/((y))$'}
				version split: ['s', 'a', 'y']
				{'string': 's/a/y', 'rgx': '((s))/((a))/((y))$'}
				ANALYSING: seg
					resolving (1)
					> version: s/e/g
					TRYING: g
					RESULT:  ['g']
				version split: ['s', 'e', 'g']
				{'string': 's/e/g', 'rgx': '((s))/((e))/((g))$'}
				ANALYSING: sei
					resolving (2)
					> version: s/e/i
					TRYING: i
					adding blocked set: C = C >> y, _, i, g
					> version: s/e/i
					TRYING: i
					adding blocked set: C = C >> y, _, i, g
					RESULT:  ['_']
				adding dashed alternative: ['s', 'e', '_', 'i']
				adding dashed alternative: ['s', 'e', '_', 'i']
				s/e/i(CVC)
s/e/i(CVV)
s/e/_/i(CVAA)
s/e/_/i(CVAA)
				version split: ['s', 'e', 'i']
				{'string': 's/e/i', 'rgx': '((s))/((e))/((_))$'}
				_____REMOVING________['s', 'e', 'i']
				version split: ['s', 'e', 'i']
				{'string': 's/e/i', 'rgx': '((s))/((e))/((_))$'}
				_____REMOVING________['s', 'e', 'i']
				version split: ['s', 'e', '_', 'i']
				{'string': 's/e/_', 'rgx': '((s))/((e))/((_))$'}
				version split: ['s', 'e', '_', 'i']
				{'string': 's/e/_', 'rgx': '((s))/((e))/((_))$'}
				ANALYSING: sey
					resolving (2)
					> version: s/e/y
					TRYING: y
					> version: s/e/y
					TRYING: y
					RESULT:  ['y']
				version split: ['s', 'e', 'y']
				{'string': 's/e/y', 'rgx': '((s))/((e))/((y))$'}
				version split: ['s', 'e', 'y']
				{'string': 's/e/y', 'rgx': '((s))/((e))/((y))$'}
				ANALYSING: sig
					resolving (2)
					> version: s/i/g
					TRYING: g
					> version: s/i/g
					TRYING: g
					RESULT:  ['g']
				version split: ['s', 'i', 'g']
				{'string': 's/i/g', 'rgx': '((s))/((i))/((g))$'}
				version split: ['s', 'i', 'g']
				{'string': 's/i/g', 'rgx': '((s))/((i))/((g))$'}
				ANALYSING: sug
					resolving (2)
					> version: s/u/g
					TRYING: g
					> version: s/u/g
					TRYING: g
					RESULT:  ['g']
				version split: ['s', 'u', 'g']
				{'string': 's/u/g', 'rgx': '((s))/((u))/((g))$'}
				version split: ['s', 'u', 'g']
				{'string': 's/u/g', 'rgx': '((s))/((u))/((g))$'}
			___CVCC : 3___
				ANALYSING: segg
				adding littera based on matching pattern
				ANALYSING: sigg
				adding littera based on matching pattern
				ANALYSING: sugg
				adding littera based on matching pattern
				ANALYSING: zigg
				adding littera based on matching pattern
				ANALYSING: zygg
				adding littera based on matching pattern
				ANALYSING: sæg
					resolving (1)
					> version: s/_/_/æ/g
					TRYING: æ
					RESULT:  ['_']
				adding dashed alternative: ['s', '_', '_', '_', 'æ', 'g']
				s/_/_/æ/g(CAAVC)
s/_/_/_/æ/g(CAAAVC)
				version split: ['s', '_', '_', 'æ', 'g']
				{'string': 's/_/_/æ/g', 'rgx': '((s))/((_))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', 'æ', 'g']
				version split: ['s', '_', '_', '_', 'æ', 'g']
				{'string': 's/_/_/_/æ', 'rgx': '((s))/((_))/((_))/((_))$'}
				_____REMOVING________['s', '_', '_', '_', 'æ', 'g']
				ANALYSING: sai
					resolving (3)
					> version: s/a/_/i
					TRYING: i
					adding blocked set: C = C >> _, i, g
					> version: s/a/_/i
					TRYING: i
					adding blocked set: C = C >> _, i, g
					> version: s/ai/_
					RESULT:  ['_']
				adding dashed alternative: ['s', 'a', '_', '_', 'i']
				adding dashed alternative: ['s', 'a', '_', '_', 'i']
				adding dashed alternative: ['s', 'ai', '_', '_']
				s/a/_/i(CVAA)
s/a/_/i(CVAA)
s/ai/_(CVA)
s/a/_/_/i(CVAAA)
s/a/_/_/i(CVAAA)
s/ai/_/_(CVAA)
				version split: ['s', 'a', '_', 'i']
				{'string': 's/a/_/i', 'rgx': '((s))/((ai)|(a))/((_))/((_))$'}
				_____REMOVING________['s', 'a', '_', 'i']
				version split: ['s', 'a', '_', 'i']
				{'string': 's/a/_/i', 'rgx': '((s))/((ai)|(a))/((_))/((_))$'}
				_____REMOVING________['s', 'a', '_', 'i']
				version split: ['s', 'ai', '_']
				{'string': 's/ai/_', 'rgx': '((s))/((ai)|(a))/((_))/((_))$'}
				_____REMOVING________['s', 'ai', '_']
				version split: ['s', 'a', '_', '_', 'i']
				{'string': 's/a/_/_/i', 'rgx': '((s))/((ai)|(a))/((_))/((_))$'}
				_____REMOVING________['s', 'a', '_', '_', 'i']
				version split: ['s', 'a', '_', '_', 'i']
				{'string': 's/a/_/_/i', 'rgx': '((s))/((ai)|(a))/((_))/((_))$'}
				_____REMOVING________['s', 'a', '_', '_', 'i']
				version split: ['s', 'ai', '_', '_']
				{'string': 's/ai/_/_', 'rgx': '((s))/((ai)|(a))/((_))/((_))$'}
				ANALYSING: say
					resolving (2)
					> version: s/a/y
					> version: s/a/y
					RESULT:  ['_']
				adding dashed alternative: ['s', 'a', 'y', '_']
				adding dashed alternative: ['s', 'a', 'y', '_']
				s/a/y(CVC)
s/a/y(CVV)
s/a/y/_(CVAA)
s/a/y/_(CVAA)
				version split: ['s', 'a', 'y']
				{'string': 's/a/y', 'rgx': '((s))/((a))/((y))/((_))$'}
				_____REMOVING________['s', 'a', 'y']
				version split: ['s', 'a', 'y']
				{'string': 's/a/y', 'rgx': '((s))/((a))/((y))/((_))$'}
				_____REMOVING________['s', 'a', 'y']
				version split: ['s', 'a', 'y', '_']
				{'string': 's/a/y/_', 'rgx': '((s))/((a))/((y))/((_))$'}
				version split: ['s', 'a', 'y', '_']
				{'string': 's/a/y/_', 'rgx': '((s))/((a))/((y))/((_))$'}
				ANALYSING: seg
					resolving (1)
					> version: s/e/g
					RESULT:  ['_']
				adding dashed alternative: ['s', 'e', 'g', '_']
				s/e/g(CVC)
s/e/g/_(CVCA)
				version split: ['s', 'e', 'g']
				{'string': 's/e/g', 'rgx': '((s))/((e))/((g))/((_))$'}
				_____REMOVING________['s', 'e', 'g']
				version split: ['s', 'e', 'g', '_']
				{'string': 's/e/g/_', 'rgx': '((s))/((e))/((g))/((_))$'}
				ANALYSING: sei
					resolving (2)
					> version: s/e/_/i
					TRYING: i
					adding blocked set: C = C >> _, i, g
					> version: s/e/_/i
					TRYING: i
					adding blocked set: C = C >> _, i, g
					RESULT:  ['_']
				adding dashed alternative: ['s', 'e', '_', '_', 'i']
				adding dashed alternative: ['s', 'e', '_', '_', 'i']
				s/e/_/i(CVAA)
s/e/_/i(CVAA)
s/e/_/_/i(CVAAA)
s/e/_/_/i(CVAAA)
				version split: ['s', 'e', '_', 'i']
				{'string': 's/e/_/i', 'rgx': '((s))/((e))/((_))/((_))$'}
				_____REMOVING________['s', 'e', '_', 'i']
				version split: ['s', 'e', '_', 'i']
				{'string': 's/e/_/i', 'rgx': '((s))/((e))/((_))/((_))$'}
				_____REMOVING________['s', 'e', '_', 'i']
				version split: ['s', 'e', '_', '_', 'i']
				{'string': 's/e/_/_/i', 'rgx': '((s))/((e))/((_))/((_))$'}
				_____REMOVING________['s', 'e', '_', '_', 'i']
				version split: ['s', 'e', '_', '_', 'i']
				{'string': 's/e/_/_/i', 'rgx': '((s))/((e))/((_))/((_))$'}
				_____REMOVING________['s', 'e', '_', '_', 'i']
				ANALYSING: sey
					resolving (2)
					> version: s/e/y
					> version: s/e/y
					RESULT:  ['_']
				adding dashed alternative: ['s', 'e', 'y', '_']
				adding dashed alternative: ['s', 'e', 'y', '_']
				s/e/y(CVC)
s/e/y(CVV)
s/e/y/_(CVAA)
s/e/y/_(CVAA)
				version split: ['s', 'e', 'y']
				{'string': 's/e/y', 'rgx': '((s))/((e))/((y))/((_))$'}
				_____REMOVING________['s', 'e', 'y']
				version split: ['s', 'e', 'y']
				{'string': 's/e/y', 'rgx': '((s))/((e))/((y))/((_))$'}
				_____REMOVING________['s', 'e', 'y']
				version split: ['s', 'e', 'y', '_']
				{'string': 's/e/y/_', 'rgx': '((s))/((e))/((y))/((_))$'}
				version split: ['s', 'e', 'y', '_']
				{'string': 's/e/y/_', 'rgx': '((s))/((e))/((y))/((_))$'}
				ANALYSING: sig
					resolving (2)
					> version: s/i/g
					> version: s/i/g
					RESULT:  ['_']
				adding dashed alternative: ['s', 'i', 'g', '_']
				adding dashed alternative: ['s', 'i', 'g', '_']
				s/i/g(CCC)
s/i/g(CVC)
s/i/g/_(CACA)
s/i/g/_(CACA)
				version split: ['s', 'i', 'g']
				{'string': 's/i/g', 'rgx': '((s))/((i))/((g))/((_))$'}
				_____REMOVING________['s', 'i', 'g']
				version split: ['s', 'i', 'g']
				{'string': 's/i/g', 'rgx': '((s))/((i))/((g))/((_))$'}
				_____REMOVING________['s', 'i', 'g']
				version split: ['s', 'i', 'g', '_']
				{'string': 's/i/g/_', 'rgx': '((s))/((i))/((g))/((_))$'}
				version split: ['s', 'i', 'g', '_']
				{'string': 's/i/g/_', 'rgx': '((s))/((i))/((g))/((_))$'}
				ANALYSING: sug
					resolving (2)
					> version: s/u/g
					> version: s/u/g
					RESULT:  ['_']
				adding dashed alternative: ['s', 'u', 'g', '_']
				adding dashed alternative: ['s', 'u', 'g', '_']
				s/u/g(CCC)
s/u/g(CVC)
s/u/g/_(CACA)
s/u/g/_(CACA)
				version split: ['s', 'u', 'g']
				{'string': 's/u/g', 'rgx': '((s))/((u))/((g))/((_))$'}
				_____REMOVING________['s', 'u', 'g']
				version split: ['s', 'u', 'g']
				{'string': 's/u/g', 'rgx': '((s))/((u))/((g))/((_))$'}
				_____REMOVING________['s', 'u', 'g']
				version split: ['s', 'u', 'g', '_']
				{'string': 's/u/g/_', 'rgx': '((s))/((u))/((g))/((_))$'}
				version split: ['s', 'u', 'g', '_']
				{'string': 's/u/g/_', 'rgx': '((s))/((u))/((g))/((_))$'}
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		only one version left: ['s', 'ai', '_', '_']
		only one version left: ['s', 'a', 'y', '_']
		only one version left: ['s', 'e', 'g', '_']
		FAIL: 
		only one version left: ['s', 'e', 'y', '_']
		only one version left: ['s', 'i', 'g', '_']
		only one version left: ['s', 'u', 'g', '_']
		SPLIT: ['s', 'e', 'g', 'g']
		SPLIT: ['s', 'i', 'g', 'g']
		SPLIT: ['s', 'u', 'g', 'g']
		SPLIT: ['z', 'i', 'g', 'g']
		SPLIT: ['z', 'y', 'g', 'g']
		SPLIT: ["['s']", "['_']", "['_']", "['_']"]
		SPLIT: ['s', 'ai', '_', '_']
		['s', 'ai', '_', '_']
		SPLIT: ['s', 'a', 'y', '_']
		['s', 'a', 'y', '_']
		['s', 'a', 'y', '_']
		SPLIT: ['s', 'e', 'g', '_']
		['s', 'e', 'g', '_']
		SPLIT: ["['s']", "['e']", "['_']", "['_']"]
		SPLIT: ['s', 'e', 'y', '_']
		['s', 'e', 'y', '_']
		['s', 'e', 'y', '_']
		SPLIT: ['s', 'i', 'g', '_']
		['s', 'i', 'g', '_']
		['s', 'i', 'g', '_']
		SPLIT: ['s', 'u', 'g', '_']
		['s', 'u', 'g', '_']
		['s', 'u', 'g', '_']
		version for pattern CVCC is INVALID
		[]
		2
		OVERVIEW: version for pattern CVCC

faulty splits: 2
['s'][''][''][''] <-! sæg
['s']['e'][''][''] <-! sei
s | e | g | g
s | i | g | g
s | u | g | g
z | i | g | g
z | y | g | g
['s'] | ['_'] | ['_'] | ['_']
s | ai | _ | _
s | a | y | _
s | e | g | _
['s'] | ['e'] | ['_'] | ['_']
s | e | y | _
s | i | g | _
s | u | g | _
1 : {'y', 'æ', 'u', 'e', 'i'}
2 : {'y', '_', 'i', 'g'},{'_', 'i', 'g'},{'y', '_', 'i', 'g'},{'_', 'i', 'g'}
3 : {'_', 'i', 'g'},{'_', 'i', 'g'},{'_', 'i', 'g'},{'_', 'i', 'g'}
	[[{'lit': 'ai', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ay', 'ln': 2, 'index': 1}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'ei', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}]]
	[[{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}], [{'lit': 'ey', 'ln': 2, 'index': 1}, {'lit': 'ey', 'ln': 2, 'index': 1}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	[[{'lit': 'gg', 'ln': 2, 'index': 2}]]
	MIN pattern length=3
	Pattern CCC is valid
	Pattern CVV is valid
	Pattern CV is invalid
	Pattern CVCC is valid
	Pattern CCCC is invalid
	Pattern CVC is valid
	Making the selection for pattern: CVC
	Selection for pattern: CVC completed
	Making a version for pattern: CVC
			___CVC : 0___
				ANALYSING: sæg
				adding littera based on matching pattern
				ANALYSING: sai
				adding littera based on matching pattern
				ANALYSING: say
				adding littera based on matching pattern
				ANALYSING: seg
				adding littera based on matching pattern
				ANALYSING: segg
				adding littera based on matching pattern
				ANALYSING: sei
				adding littera based on matching pattern
				ANALYSING: sey
				adding littera based on matching pattern
				ANALYSING: sig
				adding littera based on matching pattern
				ANALYSING: sigg
				adding littera based on matching pattern
				ANALYSING: sug
				adding littera based on matching pattern
				ANALYSING: sugg
				adding littera based on matching pattern
				ANALYSING: zigg
				adding littera based on matching pattern
				ANALYSING: zygg
				adding littera based on matching pattern
			___CVC : 1___
				ANALYSING: sæg
				adding littera based on matching pattern
				ANALYSING: sai
				adding littera based on matching pattern
				ANALYSING: say
				adding littera based on matching pattern
				ANALYSING: seg
				adding littera based on matching pattern
				ANALYSING: segg
				adding littera based on matching pattern
				ANALYSING: sei
				adding littera based on matching pattern
				ANALYSING: sey
				adding littera based on matching pattern
				ANALYSING: sig
				adding littera based on matching pattern
				ANALYSING: sigg
				adding littera based on matching pattern
				ANALYSING: sug
				adding littera based on matching pattern
				ANALYSING: sugg
				adding littera based on matching pattern
				ANALYSING: zigg
				adding littera based on matching pattern
				ANALYSING: zygg
				adding littera based on matching pattern
			___CVC : 2___
				ANALYSING: sæg
				adding littera based on matching pattern
				ANALYSING: sai
				adding littera based on matching pattern
				ANALYSING: say
				adding littera based on matching pattern
				ANALYSING: seg
				adding littera based on matching pattern
				ANALYSING: segg
				adding littera based on matching pattern
				ANALYSING: sei
				adding littera based on matching pattern
				ANALYSING: sey
				adding littera based on matching pattern
				ANALYSING: sig
				adding littera based on matching pattern
				ANALYSING: sigg
				adding littera based on matching pattern
				ANALYSING: sug
				adding littera based on matching pattern
				ANALYSING: sugg
				adding littera based on matching pattern
				ANALYSING: zigg
				adding littera based on matching pattern
				ANALYSING: zygg
				adding littera based on matching pattern
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		FAIL: 
		SPLIT: ['s', 'æ', 'g']
		SPLIT: ['s', 'a', 'i']
		SPLIT: ['s', 'a', 'y']
		SPLIT: ['s', 'e', 'g']
		SPLIT: ['s', 'e', 'gg']
		SPLIT: ['s', 'e', 'i']
		SPLIT: ['s', 'e', 'y']
		SPLIT: ['s', 'i', 'g']
		SPLIT: ['s', 'i', 'gg']
		SPLIT: ['s', 'u', 'g']
		SPLIT: ['s', 'u', 'gg']
		SPLIT: ['z', 'i', 'gg']
		SPLIT: ['z', 'y', 'gg']
		version for pattern CVC is INVALID
		[{'y', 'æ', 'u', 'e', 'i', 'a'}, {'y', 'i', 'g', 'gg'}]
		0
		OVERVIEW: version for pattern CVC
{'y', 'æ', 'u', 'e', 'i', 'a'}, {'y', 'i', 'g', 'gg'}
faulty splits: 0
s | æ | g
s | a | i
s | a | y
s | e | g
s | e | gg
s | e | i
s | e | y
s | i | g
s | i | gg
s | u | g
s | u | gg
z | i | gg
z | y | gg
	FOUND __ 0 __ VALID VERSION(S)
	OVERVIEW: version for pattern CVC
{'y', 'æ', 'u', 'e', 'i', 'a'}, {'y', 'i', 'g', 'gg'}
faulty splits: 0
s | æ | g
s | a | i
s | a | y
s | e | g
s | e | gg
s | e | i
s | e | y
s | i | g
s | i | gg
s | u | g
s | u | gg
z | i | gg
z | y | gg
	{'CCCC', 'CVCCC'}
